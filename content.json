{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"2020读书回顾","text":"本期看点：2020读书回顾，好书分享 先日常唠嗑，距离上次更新快一个月了，最近又开始在加办公了，尽量最近多写点吧。 新年订了好几个目标，希望可以做到吧。写完了才发现没加书名号，我就不加了，冒号之前的就是书名，不要吐槽。 书评大部分是当时在豆瓣上写的书评，不然不少书都忘了，评价也不准确了。 说下过滤条件，感觉很一般的书就不提了。从2020年1月开始。省流版（五星推荐，介绍在下文） 黄金时代 这样做，迈出投资第一步 火之鸟 技术书籍 黑客与画家 硅谷创业之父Paul Graham文集：很喜欢的一本书，博客上还有我的书摘，最近准备再看一遍。 MySQL必知必会：很不错的入门书，小小的一本。 Spring实战（第4版）：关于AOP和IOC的内容值得一读。 算法图解：挺有趣的数据结构和算法入门书，漫画很可爱，推荐。 Spring Boot实战：当时的评价是感觉更像说明书，最近居然还要重新看一遍，而且还看不懂了。 程序是怎样跑起来的：二进制和内存部分推荐，后半部分没啥意思。 设计模式之禅（第2版）：关于设计思想的部分非常不错,学到不少.后面的设计模式没看完。对我还是太高深了。 Java并发编程的艺术：不是很能看懂，需要重新看，推荐。 大话数据结构：还可以，就是好久没看c语言有点看不懂了，图的部分实在是看不懂，看的时候感觉罗利巴索的，搞的自己真的是一本教科书一样。 Head First Servlets &amp; JSP（中文版）：了解jsp很不错的书，刚刚手抖把书评给删了:weary:。 锋利的jQuery：挺不错的jQuery入门书，介绍了各种用法，还是比较容易阅读的。缺点是感觉有点太像说明书了。而且书中的内容在十几年后的今天还是随处可见的，没啥必要单独买。 从零开始学Python网络爬虫：一天看完了，内容比较老旧了，入门还凑合。 JavaScript DOM编程艺术 （第2版）：学习DOM相关的内容，给自己一个关于JavaScript的印象吧，不太会直接操作DOM。 Node即学即用：对于node会有一个初步的认知，后面的大部分内容属于api介绍，酌情阅读。 小结前半年在看Spring相关的书来准备找工作，中间几个月都没怎么看书了，最近开始看JavaScript和Python的书来搞新项目。新年给自己立了个大目标。 看的书基本都没怎么深入，不少书都只看了个大概，之后不能一直这样了，一点印象没有感觉还不如不读。 非技术书籍 海底捞你学不会：像是初中报纸上的一篇篇小故事，读起来还是挺有意思的，可以对海底捞有一个不错的认知。但是内容有一些流水账的感觉，很多重复的内容和重复的人，跳过的最后两章。另外推荐序特别水，非常不推荐。 你一定爱读的极简欧洲史：确实是极简的，不过还是帮我理清了希腊罗马之间的关系，还是不错的。可以看看。 血疫：7分，刚开始我是报着一本科普书的心态去看，没想到是一本类似小说的书，内容还是挺有趣的，第一章那个感染者的描述很刺激，也让我搞明白了埃博拉到底有多恐怖。个人最喜欢进入4级实验室然后泄漏的那一段，非常的身临其境。最喜欢的一句话是（大意）：病毒距离人类世界的距离不过是手指上小小的伤口，在现在这个时间看真的是别有意境。不过只看到了消灭猴舍，后面看起来都是勾心斗角就没看了。 和二木一起玩多肉：很棒的书,介绍了养多肉的方方面面，多肉入门书。 多肉萌物志：跟上面那一本一起看的，更推荐这本，插图漫画更可爱。 夏洛的网：一只蜘蛛和猪的故事，很温馨，会很羡慕这种友情。 尸人庄谜案：不推荐，一直期待作者如何解释丧尸的由来，没解释就结束不能接受。三次杀人一次是无关，一次是使用毒药，都过于简单了。 薛兆丰经济学讲义：很不错的经济学书。 东方快车谋杀案 ：这个结局不太喜欢，不过双选择的设定很有人性之善的味道。 极简人类史：我是越来越感觉有一堆推荐序的书都不靠谱了，这书也太流水账了，每一个时代都没有深入的讲一讲，只是泛泛而谈，不推荐。 神的九十亿个名字：没感觉到哪一篇的创意打动了我，第一次读这位大佬的书，确实是有自己独特的风格，但是不太习惯。 最璀璨的银河 : 刘慈欣经典作品集：又重温了一遍大刘的代表作，个人比较喜欢朝闻道，地火，流浪地球。剩下的也是非常不错的。PS：终产者的故事就出自赡养人类。 蚁族 : 大学毕业生聚居村实录：一看这都是十几年前的调查，反应北京城中村居民的现状。虽然采访的人不少，但是每个人的经历都挺相似的，基本都是因为找不到好工作。从2020年看过去，这种现象可能并没有改观，甚至更严重了吧。书的缺点在于只记录的日常生活的内容，也没有探讨更深入的东西，说是调查文学，感觉更像是日记本，虽然能不能探讨背后的内容也不好说。另外，当时的矿业土木让人羡慕，计算机无人要，真的是风水轮流转。 不可不知的数学知识 : 10个改变世界的数学公式：很浅显的一本小书，给小朋友科普挺好。 小狗钱钱 : 引导孩子正确认识财富、创造财富的“金钱童话”：算不上理财学习之类的书吧，当成儿童读物即可。因为很多东西说的过于理想化和简单化，比如成功日记。不过养鹅的说法很不错。 守夜者：看的时候总有一种似曾相识的感觉，可能真的是原来看过忘记了吧。假设这本书是我第一次读，我只能给两星，前面挖了两个大坑，为什么婴儿离奇失踪，为什么犯人愿意一起越狱，结果第一个根本就没说完，完全就是勾引继续读下去的引子，为了消灭这个引子，直接让前面写了大量笔墨的人物完全消失，感觉就像两个小说拼凑的一样。后一个更离谱，还看眼睛就催眠呢，怎么不说对面是美杜莎呢，这么厉害还越狱啥，催眠局长不好吗。最后还挖了一个大坑，我是不想看了，再见。 指数基金投资指南：基金投资入门书，虽然不是很经典，但是作为小白入门书还是可以打开理财大门的。 烧火工：充满想象力的故事，推荐一读。 低智商犯罪：很久之前看的书了，每次开头的大噱头我还是很喜欢的。 别笑，我是正经哲学书：还不错的书，算是介绍从古至今的各个哲学家，对于了解历史，了解各家思想还是不错的，每位人物还附带了其著作，如有兴趣可自行查阅。 爱你就像爱生命：看了前半本，起初还不适应单方面的对话，但是看了一点带入进去之后，就感觉自己是银河。后面开始出现银河的信，感觉像是我和王小波的对话出现了第三者，所以就没看了。开头的采访才是对我触动最深的，没有爱别人的能力，即使对的人出现了也会错过。另，里面的诗我都很喜欢。 双星：不能 称之为科幻小说吧， 如果当成普通小说看情节也有些简单了，有点鹿鼎记的感觉。 黄金时代：第一段黄金时代很喜欢，莫名的戳中我。第一次看王小波的书，确实挺惊喜。后面的两章感觉没有必要，也衔接不上，建议只看黄金时代即可。 这样做，迈出投资第一步：不记得是从什么地方看到的推荐，说是专业人士所写，便找来看了看。夜以继日的读完，是我最为推荐的理财书籍，诸君一读便知。非常推荐。 小结看的比较多的是推理书和理财书，基本都不是很满意，没有看到让人兴奋书。 年初在看关于疫情和多肉的书，这就是宅的。年中看的都是推理书，都不是很喜欢。年末看了不少理财书，果然还是开始缺钱了。 漫画 火之鸟：看了之后在我心里这就是漫画的天花板。后世的漫画，画面可以超越，思想太难。不读这本日漫也不用看别的了。缺失的最后一卷也是漫画界永远的损失吧。 镖人1-7：之前一口气看的，还是很推荐的，就是我不喜欢追书，等完结吧，有生之年系列。 内衣教父：高中就看过十几卷，九月份一口气看完了，108卷，我也是佩服我自己。读完了之后还有点空虚，加上感情分可以给8分。 星を継ぐもの：最大的悬念：人类是被火星人（貌似）创造出来的。随便看看可以。 赛雷三分钟漫画：一系列的科普漫画，都是在微信读书上看的，基本都有及格的水平，可以看看。 END","link":"/2021/02/02/2020%E8%AF%BB%E4%B9%A6%E5%9B%9E%E9%A1%BE/"},{"title":"C图解教程第5章读书笔记","text":"关键字：类的方法，本地变量，var关键字，参数 第五章 方法 方法是一块具有名称的代码，可以使用方法的名称从别的地方执行代码，也可以把数据传入方法接受数据输出。 方法由两部分组成：方法头和方法体。 方法头指定了方法的返回数据，如返回类型。方法的名称，那些数据可以传递给方法。 方法体包含可值星带的语句序列。 5.3 本地变量 在方法中也可以声明变量，语法与声明字段相同。 本地变量的存在和生产期仅限于创造它的块和其内嵌的块。 它从声明的那一点开始存在。 它在块完成执行时结束存在。 可以在任意位置声明，但是必须在使用前声明。 对比实例字段和本地变量 5.3.1 类型推断和var关键字 当编译器可以从初始化语句的右边推测出左边的类型时，可以在声明类型的位置使用关键字var 。 var关键字并不是特定类型变量的符号，它只是语法上的速记，表示可以从初始化语句的右边推断出的类型。 只能用于本地变量，不能用于字段。 只能在变量声明中包含初始化使用。 一旦编译器推断出变量的类型，那么就是固定的不能更改的。 var关键字不是JavaScript中的var那样可以引用不同的类型。C#还是强类型的性质。 5.3.2 嵌套块中的本地变量 方法体内部可以嵌套任意数量的块，可以是顺序的，也可以是更深层的嵌套，可以嵌套任意级别。 本地变量可以在嵌套块的内部声明，声明周期和可见性仅限于声明它们的块及其内嵌块。 在C和C++中，可以先声明一个本地变量，然后在嵌套块中声明另一个相同名称的本地变量，在内部中，内部名称掩盖了外部名称，但是在C#中不管如何嵌套，都不能在第一个名称的有效范围内声明另一个同名的本地变量。 5.4 本地常量 本地常量类似本地变量，只是一旦初始化后就不能改变了，如同本地变量。 使用关键字const，必须有初始化语句，初始化必须在编译器决定，可以是null引用，但是不能是对象的引用，因为对象的引用是在运行时决定的。 声明形如：consot double Pi = 3.14 5.5 控制流 选择语句 if if…else wsitch 迭代语句 for while do foreach 跳转语句 break 跳出当前循环 continue 到循环的底部 goto 到一个命名的语句 return 返回到调用方法继续执行 5.9 参数5.9.1 形参 形参是本地变量，它声明在方法的参数列表中，而不是在方法体中。 5.9.2 实参 当代码调用一个方法时，形参的值必须在方法的代码执行前被初始化。用于初始化形参的表达式或变量称为实参。 5.10 值参数 方法被调用时，系统将在栈中为形参分配空间，将实参的值复制给形参。 值参数可以是任何能计算成相应数据类型的表达式。 5.11 引用参数 使用引用参数，必须在方法和调用中都使用ref修饰符。 实参必须是变量，在作为实参前必须复制。如果是引用类型变量，可以赋值为一个引用 null。 1234void MyMethod(ref int val){ ...}int y =1;MyMethod(ref y);Mymethod(ref 2+3);//不可以,必须使用变量 引用参数不会为形参在栈上分配内存，形参的参数名作为实参变量的别名，指向相同的内存位置。 5.12 引用类型作为值参数和引用参数 将引用类型对象作为值参数传递，如果在方法内创建一个新对象并赋值给形参，将切断形参和实参之间的关联，并且在方法结束调用之后，新对象也将不复存在。 将引用类型对象作为引用参数传递，如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。 PS：跟绕口令一样。就是值参数不影响原来的实参，而引用参数会影响。 5.13 输出参数 输出参数用于从方法体内把数据传出到调用代码，它们的行为与引用参数非常类型，如同引用参数，输出参数有以下要求。 必须在声明和调用时使用修饰符，修饰符是out。 实参必须是变量，而不能是表达式，因为方法需要内存位置来保存返回值。 1234`void MyMethod(out int val){ ...}int y =1;MyMethod(out y); 以下是网络例子 12345678910111213141516171819202122232425262728using System;namespace CalculatorApplication{ class NumberManipulator { public void getValues(out int x, out int y ) { Console.WriteLine(&quot;Enter the first value: &quot;); x = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(&quot;Enter the second value: &quot;); y = Convert.ToInt32(Console.ReadLine()); } static void Main(string[] args) { NumberManipulator n = new NumberManipulator(); /* local variable definition */ int a , b; /* calling a function to get the values */ n.getValues(out a, out b); Console.WriteLine(&quot;After method call, value of a : {0}&quot;, a); Console.WriteLine(&quot;After method call, value of b : {0}&quot;, b); Console.ReadLine(); } }} 5.14 参数列表 类似Java中的可变参数，语法为void ListInts(params int[] inVals)，其中params为修饰符 可变参数必须是列表中的最后一个。 使用时可以一个一个传入实参，也可以先声明并初始化数字后传入，注意，使用时不需要写params关键字，这与其他修饰符并不一致。 如果接受的是一个一个实参，则会在方法的内部生成一个数组，让后将参数存在其中。如果传入的是数组，则会直接使用数组。 参数类型总结 5.16 方法重载 一个类中可以有一个以上的方法具有相同的名称，这叫做方法重载。 虽然名称相同，但是每个方法必须有一个地方与其他方法不同，这些地方有： 方法的名称 参数的数目 参数的数据类型和顺序 参数修饰符 注意：返回类型和形参的名称算在其中 5.17 命名参数 之前的每一次使用，实参的位置都是与对应的形参一一对应，但是我们还可以使用命名参数，只要显示指定参数的名字，就可以以任意顺序在方法调用中使用实参。形如：c.Calc(c: 2,a: 3,b: 4); 5.18 可选参数 C#允许使用可选参数，可选参数即使在嗲用方法的时候可以包含这个参数，也可以省略。为了标识某个参数是可选的，需要在方法声明的时候为参数提供默认值。形如：public int Calc(int a, int b = 3) 不是所有参数类型都可以作为可选参数，值类型都可以，引用类型只有在默认值为null的时候可以。简单总结就是在编译器可以确定这个值的才可以。 所有必填参数必须放在可选参数之前声明。可变参数放在可选参数之后声明。","link":"/2020/11/26/C%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B%E7%AC%AC5%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"C图解教程第1-4章读书笔记","text":"关键字：C#入门，基本概念，变量与常量，类的基本概念 日常闲聊，我这又开了个新坑，开始看起C#的内容了，感觉C#跟Java还是非常的像，只是各种地方换了个名字。 目前看到了第七章感觉看不下去了，说的太细了，可能等之后有了实际项目经历了再继续看，后面会陆续把写过的内容上传。 第一章 C#和.NET框架 MFC：Microsoft Foundation Class 微软基本类库 COM：Component Object Model 组件对象类型 CLR：Common Language Runtime 公共语言执行库，执行环境 CIL：Common Intermediate Language 公共中间语言 CLI：Common Language Infrastructure 公共语言基础结构，把所有NET框架的组件连结成一个内聚的，一致的系统。 BCL：基类库 执行时被编译成本机代码 第二章 C#编程概述 编译命令：csc Simple.cs，csc指“C-Sharp编译器”。 变量命名 首字母不能放首位。 @只能放首位，但是不推荐。 区分大小写。 C#关键字 关键字不能在任何地方做名称，触发加@开头。 关键字全部是小写。 2.6 语句 块：块是由成对的大括号包围的多条语句序列，在语法上相当于一条语句。形式类似Java中的代码块。 有些特定的程序结构只能使用块。 2.7 输出文本 System.Console.Write(“Hello”);//输出文本。 System.Console.WriteLine（“Hello“);//输出文本，再输出一个换行。 2.7.3 格式字符串 输出语句中可以使用多个参数，第一个参数必须是字符串，字符串中的标记符号将会被后面的参数代替，后面的值可以是字符串 数字或其他类型。 代替标记由一个整数和一对大括号组成，整数就是被替换的值的位置，从0开始。 12Console.WriteLine(&quot;Two sample integers are {0} and {1}.&quot;,3,6);Two sample integers are 3 and 6. 替换标记和参数可以是任意数量，也可以多次使用同一个参数，但是要注意不要超过参数的长度，不会产生编译错误，但是会产生运行时错误。 2.7.5 格式化数字字符串 在替换标记中可以使用参数来指定被替换数字的格式。 ![%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C#%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0%2076d478b84cd4442993f34d5190944fdd/Untitled%201.png](E:\\google\\Export-3829bbda-2b9d-4fae-8f82-4dc14e17807c\\C%23图解教程第四版读书笔记 8126ed47e6b34379989d7ff7d15347b8\\第二章 C%23编程概述 76d478b84cd4442993f34d5190944fdd\\Untitled 1.png) 格式说明符的语法 2.8 注释 单行注释，双斜杠 // 行内注释，/* xxxx */ 文档注释，/// 第三章 类型存储和变量 C程序是一组函数和数据类型， C++是一组函数和类，C#是一组类型声明。（不懂，可能代表C#内皆是类） 类型是一种模板，模板本身不是数据类型，但是它详细说明了该模板构造的对象的特征。 类型由下面的元素定义： 名称 用于保存数据成员的数据结构 一些行为和约束条件 short，int和long等类型称为简单类型，这种类型只能存储一个数据项。其他类型可以存储多个数据项，例如数组类型就可以存储多个同类型的数据项。 一些类型可以包含许多不同类型的数据项，这些类型中的数据项个体被称为成员，并且与数组中使用数字来引用成员不同，这些成员有独特的名称。 数据成员 保存了这个类的对象或者作为一个整体的类相关的数据。 函数成员执行代码，函数成员定义类型的行为。 C#中有16个预定义类型，名称全部小写。 预定义类型 3.6 用户定义类型 类类型 class 结构类型 struct 数组类型 array 枚举类型 enum 委托类型 delegate 接口类型 interface 3.7 栈和堆3.7.1 栈 栈是一个内存数据，是一个LIFO的数据类型，其中存储： 某些类型变量的值 程序当前的执行环境 传递给方法的参数 栈的特征 数据只能从栈的顶端插入和删除。 把数据放到栈顶叫做入栈 push。 从栈顶删除数据称为出栈 pop。 3.7.2 堆 堆是一块内存区域，堆中可以分配大块的内存用于存储某类型的数据对象，堆中的内存能够以任意顺序存入和移除。堆中的数据不能被显式的删除，GC会判断程序不再访问数据时删除。 堆中的自动垃圾收集 3.8 值类型和引用类型 数据项的类型定义了存储数据所需要的内存大小以及组成该类型的数据成员，还决定了对象在内存中的存储位置—栈或堆。 值引用只需要一段单独的内存，用于存储实际的数据。 引用类型需要两段内存，第一段存储实际的数据，总是位于堆中。第二段是一个引用，指向数据在堆中的存放位置。 非成员数据的存储 C#中的值类型和引用类型 变量的使用需要先声明，这将在内存中开辟一片位置，在声明后可以进行初始化，无初始化的变量有一个未定义的值，在未赋值之前不能使用，使用会产生编译错误。 一些类型的变量声明后没有初始化，那么会自动设为默认值，而一些不能。 变量类型 多变量声明：类型需要相同，名称用逗号分隔。 int var3 =7,var4,var5=3; 3.10静态类型和dynamic关键字 在C#中每个类型都是在编译期确定的并且不能在运行期修改，这叫做静态类型，但是为了兼容Python等动类类型的语言，使用dynamic关键字来代表一个特定的C#类型，它在运行时解析本身。在编译时，编译器不会对dynamic类型做类型检查。 第四章 类的基本概念 类是一种能存储数据并执行代码的数据结构，它包含数据成员和函数成员。 数据成员 存储与类或类的实例相关的数据，模拟该类所表示的现实世界的特性。 函数成员 它执行代码，模拟显式世界实物的功能和操作。 声明类：class MyExcellentClass{ 成员声明 } 字段声明：Type Identifier;例如 int MyField; C#不能声明全局变量，所有字段都属于类型，并且必须在类型声明内部声明。 4.4.2 方法 方法是具有名称的可执行代码块，可以从程序的很多不同地方执行，甚至从其他程序执行。 当方法被调用时，它执行自己所含的代码，然后返回到调用它的代码并继续执行调用代码。有些方法返回一个值到它们被调用的地方。方法相当于C++中的成员函数。 方法包括以下部分： 返回类型 声明了方法返回值的类型，如果不返回值，那么返回类型为void。 名称 参数列表 有一对圆括号组成，其中包含参数。 方法体 由一对大括号组成，其中是被执行代码。 4.5 创建变量和类的实例 类的声明只是用于创建类的实例的蓝图，一旦类被声明，就可以创建类的实例。 类是引用类型，需要为数据引用和实际数据都申请内存。 数据的引用保存在一个类类型的变量中，所有要创建类的实例，需要从声明一个类类型的变量开始，如果没有初始化，值是未定义。 创建对象和初始化例如：Dealer theDealer = new Dealer(); 类中的数据成员根据实例变化而变化，所以称之为实例变量。还有一种成员与实例无关，称为静态变量。第六章阐述。 4.8 访问修饰符 访问修饰符合计修饰在字段或方法上。 私有的 private 公有的 public 受包含的 protected 内部的 internal 受保护内部的 protected internal 如果声明时不带访问修饰符，那么就是私有成员，只能从类的内部访问，其他类不能看见。 使用private显式的修饰为私有，和隐式的没有区别，两种形式是等价的。","link":"/2020/11/26/C%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B1-4%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"Java编程思想第一周","text":"Flag高高立起：本系列目的为一年内吃透《JAVA编程思想》，暂定形式为引用原文加自我见解的形式，其中无序列表后的为见解，每周五上传这一周的笔记。 Today：2020-06-19 对象入门1.1抽象的进步 汇编语言是对基础机器的少量抽象。后来的许多“命令式”语言（如FORTRAN，BASIC 和 C）是对汇编语言的一种抽象。与汇编语言相比，这些语言已有了长足的进步，但它们的抽象原理依然要求我们着重考虑计算机的结构，而非考虑问题本身的结构。在机器模型（位于“方案空间”）与实际解决的问题模型（位于“问题空间”）之间，程序员必须建立起一种联系。这个过程要求人们付出较大的精力，而且由于它脱离了编程语言本身的范围，造成程序代码很难编写，而且要花较大的代价进行维护。由此造成的副作用便是一门完善的“编程方法”学科。 高级语言就是一种对于低级语言更加抽象后产出的结果，而低级语言是相对于汇编语言的抽象。在抽象后就可以抛弃硬件层面的问题，从而更加关注需要接近的问题。例如在c语言中还需要知道数组溢出的结果与内存的结构相关，但是在Java中就不需要考虑这个问题。 我们可理解“纯粹”的面向对象程序设计方法是什么样的： (1) 所有东西都是对象。可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。(2) 程序是一大堆对象的组合；通过消息传递，各对象知道自己该做些什么。为了向对象发出请求，需向那个对象“发送一条消息”。更具体地讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个子例程或函数。(3) 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。(4) 每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。(5) 同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法，大家不久便能理解。由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收形状消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。 万物皆对象。 程序由对象之间的调用组成。 对象可以包含，并且任意的嵌套多级。 每一个对象都是具有自身的类型。 简单说就是子类出现的地方父类一定可以替换，因为子类就是父类的特化。让代码的运行保证可行性，可预期性。 1.3实现方案的隐藏 “接口”（Interface）规定了可对一个特定的对象发出哪些请求。然而，必须在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”。站在程式化程序编写（Procedural Programming）的角度，整个问题并不显得复杂。一种类型含有与每种可能的请求关联起来的函数。一旦向对象发出一个特定的请求，就会调用那个函数。我们通常将这个过程总结为向对象“发送一条消息”（提出一个请求）。对象的职责就是决定如何对这条消息作出反应（执行相应的代码）。 接口是一种显式的定义对象可以存在何种请求或功能，但是具体如何实现则需要一些代码来实现，而这些实现并不需要显示的表达出来。 接口只是规定了是否存在，对象自身决定了如何反应。 有两方面的原因促使我们控制对成员的访问。第一个原因是防止程序员接触他们不该接触的东西——通常是内部数据类型的设计思想。若只是为了解决特定的问题，用户只需操作接口即可，毋需明白这些信息。我们向用户提供的实际是一种服务，因为他们很容易就可看出哪些对自己非常重要，以及哪些可忽略不计。进行访问控制的第二个原因是允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。例如，我们最开始可能设计了一个形式简单的类，以便简化开发。以后又决定进行改写，使其更快地运行。若接口与实现方法早已隔离开，并分别受到保护，就可放心做到这一点，只要求用户重新链接一下即可。Java 采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public，private，protected 以及暗示性的friendly。若未明确指定其他关键字，则默认为后者。这些关键字的使用和含都是相当直观的，它们决定了谁能使用后续的定义内容。“public”（公共）意味着后续的定义任何人均可使用。而在另一方面，“private”（私有）意味着除您自己、类型的创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。private在您与客户程序员之间竖起了一堵墙。若有人试图访问私有成员，就会得到一个编译期错误。“friendly”（友好的）涉及“包装”或“封装”（Package）的概念——即Java 用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。“protected”（受保护的）与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员。继承的问题不久就要谈到。 控制对对象成员的的访问就是为了保持程序的稳定性，包括不会被外部程序员进行修改，和自身的修改不会对运行结果产生运行。关键字：public，private，protected。","link":"/2020/06/22/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%80%E5%91%A8/"},{"title":"Java编程思想第七更","text":"2.6 构建 Java 程序2.6.12.6.1 名字的可见性 在所有程序设计语言里，一个不可避免的问题是对名字或名称的控制。假设您在程序的某个模块里使用了一个名字，而另一名程序员在另一个模块里使用了相同的名字。此时，如何区分两个名字，并防止两个名字互相冲突呢？这个问题在 C语言里特别突出。因为程序未提供很好的名字管理方法。C++的类（即 Java 类的基础）嵌套使用类里的函数，使其不至于同其他类里的嵌套函数名冲突。然而，C++仍然允许使用全局数据以及全局函数，所以仍然难以避免冲突。为解决这个问题，C++用额外的关键字引入了“命名空间”的概念。由于采用全新的机制，所以Java 能完全避免这些问题。为了给一个库生成明确的名字，采用了与Internet域名类似的名字。事实上，Java 的设计者鼓励程序员反转使用自己的Internet 域名，因为它们肯定是独一无二的。由于我的域名是BruceEckel.com，所以我的实用工具库就可命名为com.bruceeckel.utility.foibles。所以目前的整个软件包都以小写字母为标准。Java 的这种特殊机制意味着所有文件都自动存在于自己的命名空间里。而且一个文件里的每个类都自动获得一个独一无二的标识符（当然，一个文件里的类名必须是唯一的）。所以不必学习特殊的语言知识来解决这个问题——语言本身已帮我们照顾到这一点。 现在去回想写C语言的时候各种变量名重复冲突，完了居然还故意出这种题目让你去辨别结果，Java用域名反转来作为库名很轻松的解决了问题，不仅是在本地不会冲突，当大家都上传到云仓库中也不容易造成冲突。 2.6.2 使用其他组件 一旦要在自己的程序里使用一个预先定义好的类，编译器就必须知道如何找到它。当然，这个类可能就在发出调用的那个相同的源码文件里。如果是那种情况，只需简单地使用这个类即可——即使它直到文件的后面仍未得到定义。Java 消除了“向前引用”的问题，所以不要关心这些事情。但假若那个类位于其他文件里呢？您或许认为编译器应该足够“联盟”，可以自行发现它。但实情并非如此。假设我们想使用一个具有特定名称的类，但那个类的定义位于多个文件里。或者更糟，假设我们准备写一个程序，但在创建它的时候，却向自己的库加入了一个新类，它与现有某个类的名字发生了冲突。为解决这个问题，必须消除所有潜在的、纠缠不清的情况。为达到这个目的，要用import 关键字准确告诉Java 编译器我们希望的类是什么。import的作用是指示编译器导入一个“包”——或者说一个“类库”（在其他语言里，可将“库”想象成一系列函数、数据以及类的集合。但请记住，Java 的所有代码都必须写入一个类中）。 消除导入类的不确定性。用的最多的方法基本都是标准Java库提供了。 如果需要导入一个包下的所有类，可以使用星号作为通配符。但是不建议在正式环境中这样使用。 2.6.3 static 关键字 通常，我们创建类时会指出那个类的对象的外观与行为。除非用new 创建那个类的一个对象，否则实际上并未得到任何东西。只有执行了new 后，才会正式生成数据存储空间，并可使用相应的方法。但在两种特殊的情形下，上述方法并不堪用。一种情形是只想用一个存储区域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象。另一种情形是我们需要一个特殊的方法，它没有与这个类的任何对象关联。也就是说，即使没有创建对象，也需要一个能调用的方法。为满足这两方面的要求，可使用static（静态）关键字。一旦将什么东西设为static，数据或方法就不会同那个类的任何对象实例联系到一起。所以尽管从未创建那个类的一个对象，仍能调用一个 static方法，或访问一些 static数据。而在这之前，对于非 static数据和方法，我们必须创建一个对象，并用那个对象访问数据或方法。 这是由于非static数据和方法必须知道它们操作的具体对象。当然，在正式使用前，由于static方法不需要创建任何对象，所以它们不可简单地调用其他那些成员，同时不引用一个已命名的对象，从而直接访问非 static成员或方法（因为非static成员和方法必须同一个特定的对象关联到一起）。有些面向对象的语言使用了“类数据”和“类方法”这两个术语。它们意味着数据和方法只是为作为一个整体的类而存在的，并不是为那个类的任何特定对象。 对方法来说，static一项重要的用途就是帮助我们在不必创建对象的前提下调用那个方法。正如以后会看到的那样，这一点是至关重要的——特别是在定义程序运行入口方法main()的时候。 被static修饰的方法就与类脱离的关系，虽然还可以通过对象加点的方式使用，但是这种方法是不明确的，IDE都会提醒你切换成类名加点的方式使用，因为这个方法更像是类下属的内容，而不是一个实例化后的对象。 对于被static修饰的数据，就可以称之为类变量，这个数据就不再属于一个特定的实例了。当各个实例去使用时，获取的都是同一个数据。 2.7 我们的第一个 Java 程序 教你如何编写最初的语句，居然不是HelloWorldjava.lang包下的类可以直接使用，不需要导入。 突然发现理论性的东西都讲了一堆才开始写第一行代码，新手能忍得住吗。 介绍了加号可以连接字符串。 2.8 注释和嵌入文档 介绍了注释的几种方式，单行多行和文档注释。 小细节，private和空控制修饰符的成员注释会被忽略，这个学到了。也是符合权限控制的思想，都已经私有的方法了，没有必要让外界了解具体。 介绍了一堆可以写在文档注释里的标记，常用的有@author，@see，@param，@return，@exception等等。 2.9 编码样式 一个非正式的Java 编程标准是大写一个类名的首字母。若类名由几个单词构成，那么把它们紧靠到一起（不要用下划线来分隔名字）。此外，每个嵌入单词的首字母都采用大写形式。 这种命名法称之为驼峰命名法，不仅是在Java，在不少地方都是使用这种命名方式。 2.10 总结 第二章结束啦，下个礼拜开始第三章，控制程序流程。希望我不鸽吧。❤ END","link":"/2020/09/18/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%83%E6%9B%B4/"},{"title":"Docker简单试玩","text":"Docker的优点 打包了复杂的运行环境和配置,可以简化各种的实例化工作,各种的应用如web应用数据库应用等等都可以打包成一个镜像 硬盘的使用是MB级别,秒级启动 Docker的安装 分为社区版(CE)和企业版(EE) 要求操作系统必须是64位的,centos内核版本在3.1以上 uname -r 查询内核版本 安装指令 yum install -y docker-ce 查看安装版本 docker version 设置开机自启 systemctl enable docker 启动docker systemctl start docker 配置阿里云加速服务 我的阿里容器镜像地址 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 如果是连接Linux(CentOS)使用 在/etx/docker目录下创建daemon.json文件 vi daemon.json{ &quot;registry-mirrors&quot;: [&quot;https://99erpvmi.mirror.aliyuncs.com&quot;] } 注意缩进 sudo systemctl daemon-reload sudo systemctl restart docker 错误:执行docker image时出现 Job for docker.service failed because start of the service was attempted too often. See “systemctl status docker.service” and “journalctl -xe” for details.To force a start use “systemctl reset-failed docker.service” followed by “systemctl start docker.service” again. 解决方式：把daemon.json改为daemon.conf。使用mv命令修改后，docker启动正常。 mv daemon.json daemon.conf systemctl restart docker 查看所有的镜像(在新版本中不能再使用docker image指令,要熟悉) docker image ls 搜索镜像 docker search tomcat 错误:加速镜像不生效 尝试方法:配置阿里的加速无效,配置中科大的镜像无效,最后执行了DaoClud的脚本解决问题,猜测为文件的书写有问题 其脚本创建了daemon.json文件 {“registry-mirrors”: [“http://f1361db2.m.daocloud.io&quot;]} 删除镜像 docker rmi -f 镜像ID或镜像名:TAG -f表示强制删除 获取元信息 docker inspect 镜像ID或镜像名:TAG 删除当前容器：docker container rm 容器名 创建容器 docker run –name tom2 -d -p 8989:8080 tomcat -p为映射端口 -d为不阻塞 问题 run镜像时端口不可使用,8080 解决:新放开一个端口就可以 查看容器日志 docker logs 容器名 修改Tomcat主页内容 docker container exec -it tom2 /bin/bash ls cd webapps/ cd ROOT/ rm -f index.jsp","link":"/2020/06/22/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"Java编程思想第三更","text":"为什么拖更 最近的需求基本都搞完了，也是看起来很简单的东西搞了快一个月，确实学到了很多东西，还是上手操作学的更快啊，有机会的话会写一下其中遇到的坑和学到的东西（挖坑+1）。 因为以后不太可能每个星期都更新了，所有这个系列就不叫每周了，当然我会尽量更新一下内容的。 这两天会写一篇我在Windows下常用的软件，也算是给自己做个备忘录（挖坑+2）。 1.6.2 抽象的基础类和接口 设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口。也就是说，我们不想其他任何人实际创建基础类的一个对象，只对上溯造型成它，以便使用它们的接口。为达到这个目的，需要把那个类变成“抽象”的——使用abstract 关键字。若有人试图创建抽象类的一个对象，编译器就会阻止他们。这种工具可有效强制实行一种特殊的设计。 如果希望一个类只是用来提供接口，并且不能实例化，那么使用abstract关键字，编译器会阻止实例化 的行为。 亦可用abstract 关键字描述一个尚未实现的方法——作为一个“根”使用，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。”抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。通过创建一个抽象方法，我们可以将一个方法置入接口中，不必再为那个方法提供可能毫无意义的主体代码。interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通class 或abstract class 中继承）。 如果一个方法没有任何的实现，可以定义为抽象方法，子类在继承的时候必须实现，否则子类也必须是抽象类。 interface将抽象类的概念进一步提取，感觉是更纯粹的抽象类，在接口中所有的方法都必须是抽象的，而抽象类不一定其中都是抽象方法。并且一个类是可以多继承接口的，但是只能单继承类。这在一些方面弥补了Java单继承带来的问题。 1.7 对象的创建和存在时间 OOP（面向对象程序设计）只是涉及抽象的数据类型、继承以及多形性，但另一些问题也可能显得非常重要。 最重要的问题之一是对象的创建及破坏方式。对象需要的数据位于哪儿，如何控制对象的“存在时间”呢？ C++认为程序的执行效率是最重要的一个问题，所以它允许程序员作出选择。为获得最快的运行速度，存储以及存在时间可在编写程序时决定，只需将对象放置在堆栈（有时也叫作自动或定域变量）或者静态存储区域即可。这样便为存储空间的分配和释放提供了一个优先级。某些情况下，这种优先级的控制是非常有价值的。然而，我们同时也牺牲了灵活性，因为在编写程序时，必须知道对象的准确的数量、存在时间、以及类型。 在c++中，对象的创建使用销毁都是程序员自行处理，这里对空间的占用的控制非常自由，但是在编码的时候就非常需要注意对象是否存在等。 第二个方法是在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么。 这些参数都在程序正式运行时才决定的。若需一个新对象，只需在需要它的时候在内存堆里简单地创建它即可。由于存储空间的管理是运行期间动态进行的，所以在内存堆里分配存储空间的时间比在堆栈里创建的时间长得多（在堆栈里创建存储空间一般只需要一个简单的指令，将堆栈指针向下或向下移动即可）。 由于动态创建方法使对象本来就倾向于复杂，所以查找存储空间以及释放它所需的额外开销不会为对象的创建造成明显的影响。除此以外，更大的灵活性对于常规编程问题的解决是至关重要的。 看不懂，大概意思是说对象都是存储在内存中的，而需要使用何种对象只有在运行时才能确定。当需要一个新对象是再在内存中创建。 操作内存比操作堆栈慢许多(ps：数组好像就是存储在堆栈中使用的，切换数据只要移动一次指针就可以，所以效率非常高)。 C++允许我们决定是在写程序时创建对象，还是在运行期间创建，这种控制方法更加灵活。 大家或许认为既然它如此灵活，那么无论如何都应在内存堆里创建对象，而不是在堆栈中创建。但还要考虑另外一个问题，亦即对象的“存在时间”或者“生存时间”（Lifetime）。若在堆栈或者静态存储空间里创建一个对象，编译器会判断对象的持续时间有多长，到时会自动“破坏”或者“清除”它。 程序员可用两种方法来破坏一个对象：用程序化的方式决定何时破坏对象，或者利用由运行环境提供的一种“垃圾收集器”特性，自动寻找那些不再使用的对象，并将其清除。 当然，垃圾收集器显得方便得多，但要求所有应用程序都必须容忍垃圾收集器的存在，并能默许随垃圾收集带来的额外开销。但这并不符合C++语言的设计宗旨，所以未能包括到 C++里。 清理对象的两种方式，手动挡和自动档。显示的代码清理，隐式的GC清理。","link":"/2020/07/22/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%89%E6%9B%B4/"},{"title":"Java编程思想第九更","text":"摘要：Java中的控制语句，包括if，for，switch等。 先感慨一下，一转眼距离上次更新又是半个月过去了，主要是中间过了一个国庆，本来还天真的幻想每天都在家看书更新博客拿，实际上啥也没写，不过因为要考试还是复习了点微积分的内容，复习的时候就有点后悔高中没有好好学数学了，感觉也是想象中的那么难啊，也有可能还没学到难的部分 此处删除了关于玩文明六的大段的家长里短。 看高数的时候是我第一次拿notion写正式的笔记，体验还是挺好的，就是上传视频截图不能大于5MB，也是因为用的4K分辨率，后面可以找一个图片压缩的工具。 此处删除了我关于买了新kindle的大段家长里短。 3.2 执行控制 Java 使用了C 的全部控制语句，所以假期您以前用C或 C++编程，其中大多数都应是非常熟悉的。大多数程序化的编程语言都提供了某种形式的控制语句，这在语言间通常是共通的。在Java 里，涉及的关键字包括if-else、while、do-while、for以及一个名为 switch的选择语句。然而，Java 并不支持非常有害的goto（它仍是解决某些特殊问题的权宜之计）。仍然可以进行象goto 那样的跳转，但比典型的 goto 要局限多了。 先学C语言再学Java你就会发现控制语句是基本相同的。 Java中一直认为是保留的关键字但是没有使用goto，今天才知道还有神奇的方法去使用。即使使用之后的效果也远远不如C语言里的goto。 C 语言中的 goto 语句允许把控制无条件转移到同一函数内的被标记的语句。但是这会让代码变的难以测试和调试，所以非常不推荐使用。 3.2.1 真和假 所有条件语句都利用条件表达式的真或假来决定执行流程。条件表达式的一个例子是 A==B。它用条件运算符“==”来判断A 值是否等于 B值。该表达式返回 true 或 false。本章早些时候接触到的所有关系运算符都可拿来构造一个条件语句。注意Java 不允许我们将一个数字作为布尔值使用，即使它在 C 和 C++里是允许的（真是非零，而假是零）。若想在一次布尔测试中使用一个非布尔值——比如在if(a)里，那么首先必须用一个条件表达式将其转换成一个布尔值，例如 if(a!=0)。 Java中条件表达式里必须是一个布尔值，不能像C语言中一样使用一个数字之类的代替。 3.2.2 if-else “语句”要么是用分号结尾的一个简单语句，要么是一个复合语句——封闭在括号内的一组简单语句。在本书任何地方，只要提及“语句”这个词，就有可能包括简单或复合语句。 Java中的一个语句要么以分号结尾，要么以括号结尾，要不然可是不会给你编译通过的哦。 最好将流程控制语句缩进排列，使读者能方便地看出起点与终点。 java中的if和else是可以省略大括号的，但是一般情况下都是推荐写完整方便观看的，但是写源代码的大佬可能会为了美观会省略，这就不要随便去学了。 return关键字有两方面的用途：指定一个方法返回什么值（假设它没有 void 返回值），并立即返回那个值。 不必加上else，因为方法在遇到 return后便不再继续。 当然可以在if中使用return，这样可以让方法直接返回值，这回中断改方法后续的所有操作，不止你后面写的else。 3.2.3 反复 while，do-while和 for控制着循环，有时将其划分为“反复语句”。除非用于控制反复的布尔表达式得到“假”的结果，否则语句会重复执行下去。 关于while和do while最大区别在于他们的内部语句是否会肯定执行一次，dowhile是肯定会执行一次之后再进行判断，不过也不太常见。 for应该是最常用的循环语法了，可控初始变量，可控变化量，可控结束条件。 早在第1 章，我们已提到了逗号运算符——注意不是逗号分隔符；后者用于分隔函数的不同自变量。Java 里唯一用到逗号运算符的地方就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，我们可使用一系列由逗号分隔的语句。而且那些语句均会独立执行。 这里是指在for中初始化多个变量，或者改变多个变量的操作会用到逗号运算符，下面的例子中就初始化了两个变量i和j。 1for(int i = 1, j = i + 10; i &lt; 5;i++, j = i * 2) 3.2.6 中断和继续 在任何循环语句的主体部分，亦可用break 和continue 控制循环的流程。其中，break 用于强行退出循环，不执行循环中剩余的语句。而continue 则停止执行当前的反复，然后退回循环起始和，开始新的反复。 break和continue如字面意思，一个是中断一个是继续。在循环中使用一个代表中断循环，一个代表跳过这次循环，继续下一次的循环。 break通常是这个循环已经完成了执行的效果，就可以结束循环，而continue一遍是跳过某种不需要或者特殊情况来使用。 臭名昭著的“goto” goto 关键字很早就在程序设计语言中出现。事实上，goto 是汇编语言的程序控制结构的始祖：“若条件 A，则跳到这里；否则跳到那里”。若阅读由几乎所有编译器生成的汇编代码，就会发现程序控制里包含了许多跳转。然而，goto 是在源码的级别跳转的，所以招致了不好的声誉。若程序总是从一个地方跳到另一个地方，还有什么办法能识别代码的流程呢？随着 Edsger Dijkstra著名的“Goto 有害”论的问世，goto 便从此失宠。事实上，真正的问题并不在于使用 goto，而在于goto 的滥用。而且在一些少见的情况下，goto 是组织控制流程的最佳手段。 从灵活性上来说没有什么关键字能比goto更灵活了，但也正因为这种灵活性导致了常常被滥用，大量不规范的使用会让你的代码完全没法阅读。 后面一大堆介绍了教你如何在java中玩goto。 3.2.7 开关 “开关”（Switch）有时也被划分为一种“选择语句”。根据一个整数表达式的值，switch语句可从一系列代码选出一段执行。 switch中的内容是一个特殊的表达式，能产生整数值。switch 能将整数选择因子的结果与每个整数值比较。若发现相符的，就执行对应的语句（简单或复合语句）。若没有发现相符的，就执行default语句。 在上面的定义中，大家会注意到每个case 均以一个break 结尾。这样可使执行流程跳转至 switch主体的末尾。这是构建switch 语句的一种传统方式，但break 是可选的。若省略 break，会继续执行后面的case 语句的代码，直到遇到一个break 为止。尽管通常不想出现这种情况，但对有经验的程序员来说，也许能够善加利用。注意最后的default语句没有 break，因为执行流程已到了break 的跳转目的地。当然，如果考虑到编程风格方面的原因，完全可以在default 语句的末尾放置一个break，尽管它并没有任何实际的用处。 使用switch一定一定不要忘记break，之前看过一个小调查，不少人不愿意用switch的原因就是要加上break，到今天我也不太明白为什么设计成会层层穿透的形式，多次语句叠加起来的效果让我根本无法掌控，所以每次使用都必须加上break，而这又显得很罗嗦。 一般会用switch来代替两三个ifelse的判断，而太多分支的情况用switch也会很难看。 好在JDK12和13都对这方面做的改进，可以写出无break的switch了，但是以目前的情况推动JDK大范围的升级还是一件不太容易的事情，普遍还是使用JDK8. 3.3 总结 本章总结了大多数程序设计语言都具有的基本特性：计算、运算符优先顺序、类型转换以及选择和循环等等。现在，我们作好了相应的准备，可继续向面向对象的程序设计领域迈进。在下一章里，我们将讨论对象的初始化与清除问题，再后面则讲述隐藏的基本实现方法。 没想到这一小章这么短，下一大章就要开始介绍对象的初始化和销毁的问题了，这可是一大难点，尽量会在下个礼拜更新完这一大章的内容。已经设置提醒了，爆更一次。 END","link":"/2020/10/10/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B9%9D%E6%9B%B4/"},{"title":"Java编程思想第五更","text":"第五更 防偷窥内容（骗自己） 算是反思吧 说来还挺惭愧，六月底开始写第一篇关于Java编程思想的更新，转眼都两个月过去了，这才更新到第五期。在我的印象中好像还写了不少的博文呢。翻了一下，写了四篇分享测评类的博文 到上个星期才看到34页，但是光目录和前言就27页了，也就是60天看了5页。说出来都感觉丢人。最近在公司也挺混的，感觉自己很差劲。 最近又报名了专升本，发的课程一个礼拜了一分钟都没看呢，感觉自己找不到状态了，要振作起来，重新开始学习。既然这样就先立上Flag，在博客方面，在2020年8月结束之前看完这本书的前两章并写上博文。在上课方面还没想好复习计划，明天我再仔细思考一下。 1.7.2 单根结构 在面向对象的程序设计中，由于C++的引入而显得尤为突出的一个问题是：所有类最终是否都应从单独一个基础类继承。在Java 中（与其他几乎所有OOP语言一样），对这个问题的答案都是肯定的，而且这个终级基础类的名字很简单，就是一个“Object”。这种“单根结构”具有许多方面的优点。 单根结构中的所有对象（比如所有 Java 对象）都可以保证拥有一些特定的功能。在自己的系统中，我们知道对每个对象都能进行一些基本操作。一个单根结构，加上所有对象都在内存堆中创建，可以极大简化参数的传递（这在 C++里是一个复杂的概念） 因为都是由一个基础演化而来，所以可以保证每个对象都具有一些共同的操作，这些操作就是object中包含的方法。后一句看不懂。 利用单根结构，我们可以更方便地实现一个垃圾收集器。与此有关的必要支持可安装于基础类中，而垃圾收集器可将适当的消息发给系统内的任何对象。如果没有这种单根结构，而且系统通过一个句柄来操纵对象，那么实现垃圾收集器的途径会有很大的不同，而且会面临许多障碍。 不太懂GC这里就不评论了。但是因为所有的对象中都存在finalize()这个方法，所以GC可以更方便的回收对象。 1.7.3 集合库与方便使用集合 由于集合是我们经常都要用到的一种工具，所以一个集合库是十分必要的，它应该可以方便地重复使用。这样一来，我们就可以方便地取用各种集合，将其插入自己的程序。Java 提供了这样的一个库，尽管它在Java1.0和 1.1中都显得非常有限（Java 1.2 的集合库则无疑是一个杰作）。 1.下溯造型与模板／通用性 为了使这些集合能够重复使用，或者“再生”，Java 提供了一种通用类型，以前曾把它叫作“Object”。单根结构意味着、所有东西归根结底都是一个对象”！所以容纳了Object 的一个集合实际可以容纳任何东西。这使我们对它的重复使用变得非常简便。 因为Object这个共同父类的存在，集合的设计只需要可以容纳Object就可以包含一切的对象。 为使用这样的一个集合，只需添加指向它的对象句柄即可，以后可以通过句柄重新使用对象。 这段不讲人话，我的理解，对于集合只需要添加对象的引用即可，需要使用时从集合中取出引用就可以使用对象。 但由于集合只能容纳Object，所以在我们向集合里添加对象句柄时，它会上溯造型成 Object，这样便丢失了它的身份或者标识信息。再次使用它的时候，会得到一个Object 句柄，而非指向我们早先置入的那个类型的句柄。所以怎样才能归还它的本来面貌，调用早先置入集合的那个对象的有用接口呢？ 在这里，我们再次用到了造型（Cast）。但这一次不是在分级结构中上溯造型成一种更“通用”的类型。而是下溯造型成一种更“特殊”的类型。这种造型方法叫作“下溯造型”（Downcasting）。举个例子来说，我们知道在上溯造型的时候，Circle（圆）属于Shape（几何形状）的一种类型，所以上溯造型是安全的。但我们不知道一个Object到底是 Circle 还是Shape，所以很难保证下溯造型的安全进行，除非确切地知道自己要操作的是什么。但这也不是绝对危险的，因为假如下溯造型成错误的东西，会得到我们称为“违例”（Exception）的一种运行期错误。我们稍后即会对此进行解释。但在从一个集合提取对象句柄时，必须用某种方式准确地记住它们是什么，以保证下溯造型的正确进行。下溯造型和运行期检查都要求花额外的时间来运行程序，而且程序员必须付出额外的精力。既然如此，我们能不能创建一个“智能”集合，令其知道自己容纳的类型呢？这样做可消除下溯造型的必要以及潜在的错误。答案是肯定的，我们可以采用“参数化类型”，它们是编译器能自动定制的类，可与特定的类型配合。例如，通过使用一个参数化集合，编译器可对那个集合进行定制，使其只接受Shape，而且只提取Shape。参数化类型是C++一个重要的组成部分，这部分是C++没有单根结构的缘故。在 C++中，用于实现参数化类型的关键字是 template（模板）。Java 目前尚未提供参数化类型，因为由于使用的是单根结构，所以使用它显得有些笨拙。 关于Cast的翻译各种各样，之前看到不少人用向上造型向下造型，个人感觉没有上溯来的易懂。 任何一个对象你强`将其当作其父类去使用是一种安全的操作，但是发过来就是危险的操作。为了避免危险的操作，需要在回去集合中元素时就可以知道其是什么。这里需要的就是参数化类型，也就是常说的泛型。 泛型是一种编译期生效的手段，使得集合在存取元素时进行限制，但是在执行时并没有类似的检查。 1.7.4 清除时的困境：由谁负责清除？ 每个对象都要求资源才能“生存”，其中最令人注目的资源是内存。如果不再需要使用一个对象，就必须将其清除，以便释放这些资源，以便其他对象使用。如果要解决的是非常简单的问题，如何清除对象这个问题并不显得很突出：我们创建对象，在需要的时候调用它，然后将其清除或者“破坏”。但在另一方面，我们平时遇到的问题往往要比这复杂得多。 在Java 中，垃圾收集器在设计时已考虑到了内存的释放问题（尽管这并不包括清除一个对象涉及到的其他方面）。垃圾收集器“知道”一个对象在什么时候不再使用，然后会自动释放那个对象占据的内存空间。采用这种方式，另外加上所有对象都从单个根类Object 继承的事实，而且由于我们只能在内存堆中以一种方式创建对象，所以Java 的编程要比 C++的编程简单得多。我们只需要作出少量的抉择，即可克服原先存在的大量障碍。 1.8 违例控制：解决错误 “违例控制”将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。这里的“违例”（Exception）属于一个特殊的对象，它会从产生错误的地方“扔”或“掷”出来。随后，这个违例会被设计用于控制特定类型错误的“违例控制器”捕获。在情况变得不对劲的时候，可能有几个违例控制器并行捕获对应的违例对象。 由于采用的是独立的执行路径，所以不会干扰我们的常规执行代码。这样便使代码的编写变得更加简单，因为不必经常性强制检查代码。除此以外，“掷”出的一个违例不同于从函数返回的错误值，也不同于由函数设置的一个标志。那些错误值或标志的作用是指示一个错误状态，是可以忽略的。但违例不能被忽略，所以肯定能在某个地方得到处置。最后，利用违例能够可靠地从一个糟糕的环境中恢复。此时一般不需要退出，我们可以采取某些处理，恢复程序的正常执行。显然，这样编制出来的程序显得更加可靠。 异常也是对象，不过是特殊的对象。在Java中，Exception继承自Throwable，Throwable继承自Object，还是属于Object的子类。 因为异常的存在，我们不必经常的去进行检查，比如不用每次计算都去检查有没有除数为0，每次去提前检查NPE，没有异常可就麻烦太多了。 1.9 多线程 在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。可以通过多种途径达到这个目的。最开始的时候，那些拥有机器低级知识的程序员编写一些“中断服务例程”，主进程的暂停是通过硬件级的中断实现的。尽管这是一种有用的方法，但编出的程序很难移植，由此造成了另一类的代价高昂问题。 有些时候，中断对那些实时性很强的任务来说是很有必要的。但还存在其他许多问题，它们只要求将问题划分进入独立运行的程序片断中，使整个程序能更迅速地响应用户的请求。在一个程序中，这些独立运行的片断叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程处理一个常见的例子就是用户界面。利用线程，用户可按下一个按钮，然后程序会立即作出响应，而不是让用户等待程序完成了当前任务以后才开始响应。 最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器。程序在逻辑意义上被分割为数个线程；假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。 根据前面的论述，大家可能感觉线程处理非常简单。但必须注意一个问题：共享资源！如果有多个线程同时运行，而且它们试图访问相同的资源，就会遇到一个问题。举个例子来说，两个进程不能将信息同时发送给一台打印机。为解决这个问题，对那些可共享的资源来说（比如打印机），它们在使用期间必须进入锁定状态。所以一个线程可将资源锁定，在完成了它的任务后，再解开（释放）这个锁，使其他线程可以接着使用同样的资源。 Java 的多线程机制已内建到语言中，这使一个可能较复杂的问题变得简单起来。对多线程处理的支持是在对象这一级支持的，所以一个执行线程可表达为一个对象。Java 也提供了有限的资源锁定方案。它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间。为达到这个目的，需要使用synchronized关键字。其他类型的资源必须由程序员明确锁定，这通常要求程序员创建一个对象，用它代表一把锁，所有线程在访问那个资源时都必须检查这把锁。 如果多线程运行在多个不同的处理器上，这就是并行计算，当使用更多处理器的机器自动就可以提升程序效率。 为了处理多线程资源访问的问题而出现了锁，一个锁可以让一个资源在一段时间中只被一个线程去操作。 1.10 永久性 创建一个对象后，只要我们需要，它就会一直存在下去。但在程序结束运行时，对象的“生存期”也会宣告结束。 尽管这一现象表面上非常合理，但深入追究就会发现，假如在程序停止运行以后，对象也能继续存在，并能保留它的全部信息，那么在某些情况下将是一件非常有价值的事情。下次启动程序时，对象仍然在那里，里面保留的信息仍然是程序上一次运行时的那些信息。 当然，可以将信息写入一个文件或者数据库，从而达到相同的效果。但尽管可将所有东西都看作一个对象，如果能将对象声明成“永久性”，并令其为我们照看其他所有细节，无疑也是一件相当方便的事情。Java 1.1 提供了对“有限永久性”的支持，这意味着我们可将对象简单地保存到磁盘上，以后任何时间都可取回。之所以称它为“有限”的，是由于我们仍然需要明确发出调用，进行对象的保存和取回工作。这些工作不能自动进行。 对象的信息如果可以在程序运行结束之后还存在，那么下次运行的时候就可以利用这些信息，这些信息可以存放在文件或者数据库中。 Java可以对对象进行序列化操作，但是需要自己在代码中显示的使用。 END","link":"/2020/08/18/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%BA%94%E6%9B%B4/"},{"title":"Java编程思想第八更","text":"内容导读：Java运算符，位运算，逻辑运算 第三章：控制程序流程 “就象任何有感知的生物一样，程序必须能操纵自己的世界，在执行过程中作出判断与选择。” 好像是扎克伯格说过，程序的优点就是可以执行一个动作成千上万次。一段代码加上循环和判断可以成为一个简单的文字游戏。 3.1 使用 Java 运算符 几乎所有运算符都只能操作“主类型”（Primitives）。唯一的例外是“=”、“==”和“!=”，它们能操作所有对象（也是对象易令人混淆的一个地方）。除此以外，String 类支持“+”和“+=”。 Java也支持其他所有编程语言所支持的加减乘除，但是为了简化字符串的操作，还可以在字符串上使用加号来连接两个字符串。 ==和!=基本就脱离了计算符号，而是作为一个逻辑判断的符号。 3.1.1 优先级 先乘除后加减，有括号先算括号，幼儿园都知道，剩下的就不用考虑了。 原来看绿皮的那本C语言，里面不停的强调各种操作符的优先级，搞的我一直在背那个傻东西，学计算机学到这种地步也是诡异。 3.1.2 赋值 赋值是用等号运算符（=）进行的。它的意思是“取得右边的值，把它复制到左边”。右边的值可以是任何常数、变量或者表达式，只要能产生一个值就行。 这里的等号就不代表数学中的相等，指代一种数据的转移，将右边的数据存储到左边的符号中。 但在为对象“赋值”的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是它的句柄。所以倘若“从一个对象到另一个对象”赋值，实际就是将句柄从一个地方复制到另一个地方。这意味着假若为对象使用“C=D”，那么C 和 D最终都会指向最初只有 D 才指向的那个对象。 在Java中对象间传递的是引用，而不是对象。例如A=B=C，对C做改动A和B都会变化，因为他们本质上指向的就是同一个对象。 3.1.3 算术运算符 整数除法会直接舍弃小数，而不是四舍五入。 3.1.4 自动递增和递减 对于基本类型可以使用++或者–符号，代表在此基础上加1或者减1，是非常常用的符号。 ++和–可以添加在数字的前面或者后面，在前面意味着先改变值再执行。同理，在后面代表先执行语句，后改变值。不要问我a++++a是多少，纠结这个就是傻子。包括我。 3.1.5 关系运算符 关系运算符生成的是一个“布尔”（Boolean）结果。它们评价的是运算对象值之间的关系。若关系是真实的，关系表达式会生成 true（真）；若关系不真实，则生成false（假）。关系运算符包括小于（&lt;）、大于（&gt;）、小于或等于（&lt;=）、大于或等于（&gt;=）、等于（==）以及不等于（!=）。等于和不等于适用于所有内建的数据类型，但其他比较不适用于boolean 类型。 在人类的世界是有成功与失败，通过与否决，可以与不可以等等概念，我们需要电脑也能明白这个道理，于是就发明了boolean这个类型，它是只有两个值的类型，true和false，代表真和假。 ==和equal ==可以在基本类型和引用类型上使用，因为==是直接比较目标地址的内容，所以就会产生两种情况。如果是基本类型，地址里存放的就是自身的值，比较就是正确的。但是如果是引用类型，地址里存放的就是引用，除非是指向同一片地址，否则就是false，即使new了两个一模一样的张三，比较还是false。当然还有Integer的特殊情况，请自行查阅。 使用equal方法时，因为equal是继承与Object，在Object中默认的实现就是使用==符号进行比较，但是这样得出的结果就不是我们想要的比较内容了，所以一般情况下都是要重写equal方法的，具体如何重写有ide给你生成好了。好像是利用hash值进行的比较。 3.1.6 逻辑运算符 逻辑运算符 AND（&amp;&amp;）、OR（||）以及 NOT（!）能生成一个布尔值（true 或 false）——以自变量的逻辑关系为基础。下面这个例子向大家展示了如何使用关系和逻辑运算符。 上面我们已经发明了逻辑符号，但是有些情况是需要多个逻辑来决定下一步行为，我们需要组合逻辑，这就有了与或非。 与C与C++不同，不可以在逻辑运输符号的两边使用非布尔值，你不能像在C语言中一样1&amp;&amp;1了。我认为你是非常好的改革，可以把数字和布尔值区分开， 不会再滥用数字在逻辑判断中。 其实使用一个&amp;和|也是逻辑符号，但是为了简化逻辑式的执行，就有了短路逻辑运算，也就是使用两次这个符号，这样当式子已经不可能等于另一个值时就会跳过后面的计算了。正常情况直接用短路符号即可。不要问我用短路符号和不用短路符号的区别，然后在表达式里搞一堆数学计算，你就去问谭浩强吧。 3.1.7 按位运算符 按位运算符允许我们操作一个整数主数据类型中的单个“比特”，即二进制位。按位运算符会对两个自变量中对应的位执行布尔代数，并最终生成一个结果 按位运算来源于C 语言的低级操作。我们经常都要直接操纵硬件，需要频繁设置硬件寄存器内的二进制位。Java 的设计初衷是嵌入电视顶置盒内，所以这种低级操作仍被保留下来了。然而，由于操作系统的进步，现在也许不必过于频繁地进行按位运算。 3.1.8 移位运算符 移位运算符面向的运算对象也是二进制的“位”。可单独用它们处理整数类型（主类型的一种）。左移位运算符（&lt;&lt;）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补 0）。“有符号”右移位运算符（&gt;&gt;）则将运算符左边的运算对象向右移动运算符右侧指定的位数。“有符号”右移位运算符使用了“符号扩展”：若值为正，则在高位插入0；若值为负，则在高位插入1。Java 也添加了一种“无符号”右移位运算符（&gt;&gt;&gt;），它使用了“零扩展”：无论正负，都在高位插入0。这一运算符是C 或C++没有的。 三种位移运算符，左移&lt;&lt;右移&gt;&gt;无符号右移&gt;&gt;&gt;，右移的结果可不一定等于想象中的数学结果，但是符合电路二进制的结果。我感觉，最后一种可以称为数学右移，因为就是为了快速正确的进行二进制计算而发明的。 正常最多看到用左移1来加快计算翻倍，剩下的两个都少见。 3.1.9 三元 if-else 运算符 布尔表达式 ? 值 0:值 1若“布尔表达式”的结果为true，就计算“值0”，而且它的结果成为最终由运算符产生的值。但若“布尔表达式”的结果为false，计算的就是“值 1”，而且它的结果成为最终由运算符产生的值。 三元运算符号很像一个if加else，事实上也可以拿来代替简单的一层ifelse。可以让你的代码简洁不少，但是如果逻辑复杂还是建议使用ifelse，因为一旦过长可读性就会很差，因为我可能冒号在哪里都要找一会。 3.1.10 逗号运算符 只在for循环中有用到，用来在一个部分执行两个或更多操作。 3.1.11 字串运算符+ 如果在字符串后面加上加号，然后跟上其他的内容，都会被编译成先将后面的内容转string，然后连接字符串。 3.1.13 造型运算符 “造型”（Cast）的作用是“与一个模型匹配”。在适当的时候，Java 会将一种数据类型自动转换成另一种。例如，假设我们为浮点变量分配一个整数值，计算机会将 int自动转换成 float。通过造型，我们可明确设置这种类型的转换，或者在一般没有可能进行的时候强迫它进行。 正如您看到的那样，既可对一个数值进行造型处理，亦可对一个变量进行造型处理。但在这儿展示的两种情况下，造型均是多余的，因为编译器在必要的时候会自动进行 int值到long 值的转换。当然，仍然可以设置一个造型，提醒自己留意，也使程序更清楚。 一般情况下“小类型“当作”大类型使用时都会隐形的自动转换，但是如果需要大转小，这种操作是具有丢失信息甚至失败的风险，需要手动的去操作。 3.1结束，java的操作符号说起来很简单，但是其中还是有不少小细节，需要自己注意，尤其是位运算和数字类型转换的问题。 一个半小时写一小节还是很爽的，虽然比较简单的内容。 Typora换了pai主题，还挺好看的。 END","link":"/2020/09/24/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%85%AB%E6%9B%B4/"},{"title":"Java编程思想第二周","text":"内容导读：继承，类型转换 1.5 继承：重新使用接口 我们费尽心思做出一种数据类型后，假如不得不又新建一种类型，令其实现大致相同的功能，那会是一件非常令人灰心的事情。但若能利用现成的数据类型，对其进行“克隆”，再根据情况进行添加和修改，情况就显得理想多了。“继承”正是针对这个目标而设计的。但继承并不完全等价于克隆。在继承过程中，若原始类（正式名称叫作基础类、超类或父类）发生了变化，修改过的“克隆”类（正式名称叫作继承类或子类）也会反映出这种变化。在Java 语言中，继承是通过 extends关键字实现的使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private 成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。根据可以发送的消息，我们能知道类的类型。这意味着衍生类具有与基础类相同的类型！为真正理解面向对象程序设计的含义，首先必须认识到这种类型的等价关系。 首先，继承是为了复用代码而出现，但是又不是使用完全相同的代码，所以子类一般会有额外的修改，但是除此之外皆与父类系统。 这里的接口指的应该是方法，父类中存在的方法则在子类中一定存在，这样面对一个已知父类下的子类时，则可以使用与父类相同名称的方法来调用子类，而不用担心不存在这个接口。 由于基础类和衍生类具有相同的接口，所以那个接口必须进行特殊的设计。也就是说，对象接收到一条特定的消息后，必须有一个“方法”能够执行。若只是简单地继承一个类，并不做其他任何事情，来自基础类接口的方法就会直接照搬到衍生类。这意味着衍生类的对象不仅有相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。 如果不重写子类的实现，则其功能与父类完全相同，这样子类的存在则没有什么意义。当然一个子类不一定会重写父类所有的方法，但是最起码会修改一个方法。 1.5.2 等价与类似关系 针对继承可能会产生这样的一个争论：继承只能改善原基础类的函数吗？若答案是肯定的，则衍生类型就是与基础类完全相同的类型，因为都拥有完全相同的接口。这样造成的结果就是：我们完全能够将衍生类的一个对象换成基础类的一个对象！可将其想象成一种“纯替换”。在某种意义上，这是进行继承的一种理想方式。此时，我们通常认为基础类和衍生类之间存在一种“等价”关系——因为我们可以理直气壮地说：“圆就是一种几何形状”。为了对继承进行测试，一个办法就是看看自己是否能把它们套入这种“等价”关系中，看看是否有意义。 但在许多时候，我们必须为衍生类型加入新的接口元素。所以不仅扩展了接口，也创建了一种新类型。这种新类型仍可替换成基础类型，但这种替换并不是完美的，因为不可在基础类里访问新函数。我们将其称作“类似”关系；新类型拥有旧类型的接口，但也包含了其他函数，所以不能说它们是完全等价的。 父类存在的地方则一定可以替换成子类来使用，这就是替换。但是父类可能是无法替换子类出现的地方，因为子类可能存在新建的接口，而这个接口是父类所不存在的，这是类似。 1.6 多形对象的互换使用 对这样的一系列类（形状类下有圆形正方形等子类），我们要进行的一项重要处理就是将衍生类的对象当作基础类的一个对象对待。这一点是非常重要的，因为它意味着我们只需编写单一的代码，令其忽略类型的特定细节，只与基础类打交道。这样一来，那些代码就可与类型信息分开。所以更易编写，也更易理解。此外，若通过继承增添了一种新类型，如“三角形”，那么我们为“几何形状”新类型编写的代码会象在旧类型里一样良好地工作。所以说程序具备了“扩展能力”，具有“扩展性”。 编写代码面向父类，面向抽象编写，这样在添加，修改，删除子类时，不会对代码造成巨大破坏。同时这样的代码具备扩展的能力，当需要新的功能时，新增一个子类即可，不会对原有的运行代码造成破坏。 一个 Circle（圆）句柄传递给一个本来期待 Shape（形状）句柄的函数。由于圆是一种几何形状，所以doStuff()能正确地进行处理。也就是说，凡是 doStuff()能发给一个 Shape的消息，Circle也能接收。所以这样做是安全的，不会造成错误。我们将这种把衍生类型当作它的基本类型处理的过程叫作“Upcasting”（上溯造型）。其中，“cast”（造型）是指根据一个现成的模型创建；而“Up”（向上）表明继承的方向是从“上面”来的——即基础类位于顶部，而衍生类在下方展开。所以，根据基础类进行造型就是一个从上面继承的过程，即“Upcasting”。在面向对象的程序里，通常都要用到上溯造型技术。这是避免去调查准确类型的一个好办法。 把子类当作父类去使用接口的方式称为上溯造型，表示向继承的上方，也就是父类一样去cast自身后使用。这一行为在Java编码中非常的常用。 PS：这周换工作地点了，熟悉（懒）一周，所以就看了一天，从下个星期开始会继续更新的。 END","link":"/2020/06/29/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%BA%8C%E5%91%A8/"},{"title":"Java编程思想第十一更","text":"关键字：垃圾回收，finalize，数组，初始化 先例行闲聊 距离上次更新过去半个月了，期间一直在准备考试，当然也没看几天书，全靠最后两天临时抱佛脚。考试监考还是挺严格的，来考试的人也比我想象的年纪大写，考场中年纪最大的一个目测也有三十多了。考英语的时候一哥们问老师为啥还不放听力，老师说再等等，其实根本就没有听力考试。 4.3 清除：收尾和垃圾收集 程序员都知道“初始化”的重要性，但通常忘记清除的重要性。毕竟，谁需要来清除一个int呢？但是对于库来说，用完后简单地“释放”一个对象并非总是安全的。当然，Java 可用垃圾收集器回收由不再使用的对象占据的内存。 现在考虑一种非常特殊且不多见的情况。假定我们的对象分配了一个“特殊”内存区域，没有使用new。垃圾收集器只知道释放那些由new分配的内存，所以不知道如何释放对象的“特殊”内存。 为解决这个问题，Java 提供了一个名为finalize()的方法，可为我们的类定义它。在理想情况下，它的工作原理应该是这样的：一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存。所以如果使用finalize()，就可以在垃圾收集期间进行一些重要的清除或清扫工作。 初始化要小心，释放同样要注意。一些特殊的内存占用可以通知GC来清理掉，而通知的方法就是调用finalize()方法。要注意的这个方法不是直接的销毁对象，而是通知GC前来处理，所以这也算不上C语言中的破坏器。 垃圾收集并不等于“破坏”！ 我们的对象可能不会当作垃圾被收掉！ 4.3.1 finalize() 用途何在 垃圾收集只跟内存有关！ 垃圾收集器存在的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾收集有关的任何活动来说，其中最值得注意的是finalize()方法，它们也必须同内存以及它的回收有关。 这是否意味着假如对象包含了其他对象，finalize()就应该明确释放那些对象呢？答案是否定的——垃圾收集器会负责释放所有对象占据的内存，无论这些对象是如何创建的。它将对finalize()的需求限制到特殊的情况。在这种情况下，我们的对象可采用与创建对象时不同的方法分配一些存储空间。 4.3.2 必须执行清除 Java 不允许我们创建本地（局部）对象——无论如何都要使用new。但在Java 中，没有“delete”命令来释放对象，因为垃圾收集器会帮助我们自动释放存储空间。 所以如果站在比较简化的立场，我们可以说正是由于存在垃圾收集机制，所以 Java 没有破坏器。 然而，随着以后学习的深入，就会知道垃圾收集器的存在并不能完全消除对破坏器的需要，或者说不能消除对破坏器代表的那种机制的需要（而且绝对不能直接调用finalize()，所以应尽量避免用它）。若希望执行除释放存储空间之外的其他某种形式的清除工作，仍然必须调用Java 中的一个方法。它等价于 C++的破坏器，只是没后者方便。 finalize()最有用处的地方之一是观察垃圾收集的过程。 ？：为啥不能直接调用finalize？ 原文后面举了一个重写finalize的例子，表示GC可能会出问题在Java1.1里。 4.4 成员初始化 Java 尽自己的全力保证所有变量都能在使用前得到正确的初始化。若被定义成相对于一个方法的“局部”变量，这一保证就通过编译期的出错提示表现出来。 没太看懂后一句，举例子是一个变量声明了但是没有初始化。 当然，编译器也可为i 赋予一个默认值，但它看起来更象一个程序员的失误，此时默认值反而会“帮倒忙”。若强迫程序员提供一个初始值，就往往能够帮他／她纠出程序里的“臭虫”。 然而，若将基本类型（主类型）设为一个类的数据成员，情况就会变得稍微有些不同。由于任何方法都可以初始化或使用那个数据，所以在正式使用数据前，若还是强迫程序员将其初始化成一个适当的值，就可能不是一种实际的做法。然而，若为其赋予一个垃圾值，同样是非常不安全的。因此，一个类的所有基本类型数据成员都会保证获得一个初始值。 没太明白为什么基本类型就不能没有初始值，我感觉这是从底层内存出发就可以解释的，不知道为什么解释的我听不懂。 基本类型都会有一个初始的默认值，有时候会帮忙，有时候会捣乱。 4.4.1 规定初始化 如果想自己为变量赋予一个初始值，又会发生什么情况呢？为达到这个目的，一个最直接的做法是在类内部定义变量的同时也为其赋值。 也就是在类中直接就对变量进行初始化，给类型设置默认值。 4.4.2 构建器初始化 可考虑用构建器执行初始化进程。这样便可在编程时获得更大的灵活程度，因为我们可以在运行期调用方法和采取行动，从而“现场”决定初始化值。但要注意这样一件事情：不可妨碍自动初始化的进行，它在构建器进入之前就会发生。 当然更推荐通过构造器来初始化，这样会让对象更加低耦合。 初始化顺序 在一个类里，初始化的顺序是由变量在类内的定义顺序决定的。即使变量定义大量遍布于方法定义的中间，那些变量仍会在调用任何方法之前得到初始化——甚至在构建器调用之前。 静态数据的初始化 若数据是静态的（static），那么同样的事情就会发生；如果它属于一个基本类型（主类型），而且未对其初始化，就会自动获得自己的标准基本类型初始值；如果它是指向一个对象的句柄，那么除非新建一个对象，并将句柄同它连接起来，否则就会得到一个空值（NULL）。如果想在定义的同时进行初始化，采取的方法与非静态值表面看起来是相同的。但由于static 值只有一个存储区域，所以无论创建多少个对象，都必然会遇到何时对那个存储区域进行初始化的问题。 静态变量的初始和普通变量相同，基本类型有初始值其他的为Null。但是静态数据只能去初始化一次。 明确进行的静态初始化 Java 允许我们将其他static初始化工作划分到类内一个特殊的“static 构建从句”（有时也叫作“静态块”）里。 尽管看起来象个方法，但它实际只是一个static 关键字，后面跟随一个方法主体。与其他 static初始化一样，这段代码仅执行一次——首次生成那个类的一个对象时，或者首次访问属于那个类的一个 static 成员时（即便从未生成过那个类的对象）。 其实静态块和各种初始化还是区分先后顺序的，但是不要去死记硬背。 非静态实例的初始化 针对每个对象的非静态变量的初始化，Java 1.1 提供了一种类似的语法格式。 语法类似与声明变量后，加大括号，括号内进行初始化，感觉像是匿名内部类的样式。 它看起来与静态初始化从句极其相似，只是static 关键字从里面消失了。为支持对“匿名内部类”的初始化（参见第7 章），必须采用这一语法格式。 4.5 数组初始化 数组代表一系列对象或者基本数据类型，所有相同的类型都封装到一起——采用一个统一的标识符名称。数组的定义和使用是通过方括号索引运算符进行的（[]）。为定义一个数组，只需在类型名后简单地跟随一对空方括号即可。 也可以将方括号置于标识符后面，获得完全一致的结果。 这种格式与 C和 C++程序员习惯的格式是一致的。然而，最“通顺”的也许还是前一种语法，因为它指出类型是“一个 int 数组”。本书将沿用那种格式。 数组和基本类型一样是天然会出现在一种编程语言中的，因为这是最基本的对数据的收集和处理。也正是因为数组的种种缺陷，才让各种数据结构有了自己的发挥空间。不过在访问速度等方面，数组还是无法被超越的。 关于数组的初始化写成int[]还是int a[]的争论也是有不少，前一种更能清楚的IPv6宝石这个一个什么类型的数组，后一种写法则更清晰的表示这个变量是一个数组，Java中普遍还是使用后一种写法。 编译器不允许我们告诉它一个数组有多大。这样便使我们回到了“句柄”的问题上。此时，我们拥有的一切就是指向数组的一个句柄，而且尚未给数组分配任何空间。为了给数组创建相应的存储空间，必须编写一个初始化表达式。对于数组，初始化工作可在代码的任何地方出现，但也可以使用一种特殊的初始化表达式，它必须在数组创建的地方出现。这种特殊的初始化是一系列由花括号封闭起来的值。 最基本的初始化就是在括号中直接写明其中具有什么元素。 所有数组都有一个本质成员（无论它们是对象数组还是基本类型数组），可对其进行查询——但不是改变，从而获知数组内包含了多少个元素。这个成员就是 length。 与C和 C++类似，由于Java 数组从元素 0 开始计数，所以能索引的最大元素编号是“length-1”。如超出边界，C 和C++会“默默”地接受，并允许我们胡乱使用自己的内存，这正是许多程序错误的根源。然而，Java 可保留我们这受这一问题的损害，方法是一旦超过边界，就生成一个运行期错误（即一个“违例”，这是第9 章的主题）。 当然，由于需要检查每个数组的访问，所以会消耗一定的时间和多余的代码量，而且没有办法把它关闭。这意味着数组访问可能成为程序效率低下的重要原因——如果它们在关键的场合进行。但考虑到因特网访问的安全，以及程序员的编程效率，Java 设计人员还是应该把它看作是值得的。 所有的数组都有一个内部的变量来表示其长度，不然一个没有长度的数组可是很可怕的。 在C系列中，对数组的读取超过了边界，你就会看到很多奇奇怪怪的东西，如果没有发现问题就可能让你的程序跑偏。在Java中就不运行这样的操作，会直接生成一个错误来阻止继续运行。虽然这样会影响到运算速度，但是和安全比这还是值得的。 4.5.1 多维数组 在Java 里可以方便地创建多维数组 1234int[][] a1 = {{ 1, 2, 3, },{ 4, 5, 6, },}; 形如大括号中套大括号来初始化，不要纠结多为数组的使用和计算，多为数组很少被使用，不要上了谭浩强的当。 后面的例子展示了三维数组，这就更没必要了。 4.6 总结 作为初始化的一种具体操作形式，构建器应使大家明确感受到在语言中进行初始化的重要性。 由于构建器使我们能保证正确的初始化和清除（若没有正确的构建器调用，编译器不允许对象创建），所以能获得完全的控制权和安全性。 不好好调用构造器都不允许插件对象以此来保护对象的安全。 在C++中，与“构建”相反的“破坏”（Destruction）工作也是相当重要的，因为用new 创建的对象必须明确地清除。 在Java 中，垃圾收集器会自动为所有对象释放内存，所以 Java 中等价的清除方法并不是经常都需要用到的。如果不需要类似于构建器的行为，Java 的垃圾收集器可以极大简化编程工作，而且在内存的管理过程中增加更大的安全性。有些垃圾收集器甚至能清除其他资源，比如图形和文件句柄等。然而，垃圾收集器确实也增加了运行期的开销。 GC的优缺点也是老生常谈了。 由于所有对象都肯定能获得正确的构建，所以同这儿讲述的情况相比，构建器实际做的事情还要多得多。特别地，当我们通过“创作”或“继承”生成新类的时候，对构建的保证仍然有效，而且需要一些附加的语法来提供对它的支持。大家将在以后的章节里详细了解创作、继承以及它们对构建器造成的影响。 创建子类好像还和父类的构造器有关系，后面我们一起了解。 PS：感觉这一章翻译的很不顺口不知道为什么。 下一章，隐藏实施过程。下次再见啦，我要去买个烧饼吃。 END","link":"/2020/10/30/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E4%B8%80%E6%9B%B4/"},{"title":"Java编程思想第十二更","text":"关键字：导包，Java访问控制符 第五章：隐藏实施过程 “进行面向对象的设计时，一项基本的考虑是：如何将发生变化的东西与保持不变的东西分隔开。” 最基础操作，配置内容要独立为配置文件，常用的内容配置成常量。甚至可以声明一个静态量用来存储常用数据。 这一点对于库来说是特别重要的。那个库的用户（客户程序员）必须能依赖自己使用的那一部分，并知道一旦新版本的库出台，自己不需要改写代码。而与此相反，库的创建者必须能自由地进行修改与改进，同时保证客户程序员代码不会受到那些变动的影响。 库的修改不能影响已经运行的代码，写的代码也不能因为库的更新而产生变化。这就需要接口的规范了。 为解决这个问题，Java 推出了“访问指示符”的概念，允许库创建者声明哪些东西是客户程序员可以使用的，哪些是不可使用的。这种访问控制的级别在“最大访问”和“最小访问”的范围之间，分别包括：public，“友好的”（无关键字），protected 以及private。 中间大量内容提到Java中包的导入与命名，此处不表。 5.2 Java 访问指示符 如果根本不指定访问指示符，默认的访问没有关键字，但它通常称为“友好”（Friendly）访问。这意味着当前包内的其他所有类都能访问“友好的”成员，但对包外的所有类来说，这些成员却是“私有”（Private）的，外界不得访问。 5.2.3 private ：不能接触！ private关键字意味着除非那个特定的类，而且从那个类的方法里，否则没有人能访问那个成员。同一个包内的其他成员不能访问 private成员，这使其显得似乎将类与我们自己都隔离起来。 5.2.4 protected：“友好的一种” protected 关键字为我们引入了一种名为“继承”的概念，它以现有的类为基础，并在其中加入新的成员，同时不会对现有的类产生影响——我们将这种现有的类称为“基础类”或者“基本类”（Base Class）。 5.4 类访问 (1) 每个编译单元（文件）都只能有一个public 类。每个编译单元有一个公共接口的概念是由那个公共类表达出来的。根据自己的需要，它可拥有任意多个提供支撑的“友好”类。但若在一个编译单元里使用了多个public类，编译器就会向我们提示一条出错消息。(2) public类的名字必须与包含了编译单元的那个文件的名字完全相符，甚至包括它的大小写形式。所以对于Widget 来说，文件的名字必须是Widget.java，而不应是 widget.java或者WIDGET.java。同样地，如果出现不符，就会报告一个编译期错误。 小的限制，但是很少会遇到。 5.5 总结 如果不制订规则，客户程序员就可以随心所欲地操作一个类的所有成员，无论我们本来愿不愿意其中的一些成员被直接操作。所有东西都在别人面前都暴露无遗。 一个类的公共接口是所有用户都能看见的，所以在进行分析与设计的时候，这是应尽量保证其准确性的最重要的一个部分。但也不必过于紧张，少许的误差仍然是允许的。若最初设计的接口存在少许问题，可考虑添加更多的方法，只要保证不删除客户程序员已在他们的代码里使用的东西。 兼容老代码是如此的重要。 END","link":"/2020/12/13/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E4%BA%8C%E6%9B%B4/"},{"title":"Java编程思想第十更","text":"关键词：构造器，重载，this关键字，static关键字 突然试了一下Typora的Blubook的主题，感觉很好看啊，标注了每一个标题的具体等级，还给引用的内容加上了立体效果，用来写书摘类型的博客很合适，很推荐试一试，就是不知道能不应用到博客的主题上去，有空研究一下。 第 4 章 初始化和清除 “随着计算机的进步，‘不安全’的程序设计已成为造成编程代价高昂的罪魁祸首之一。”“初始化”和“清除”是这些安全问题的其中两个。许多 C程序的错误都是由于程序员忘记初始化一个变量造成的。对于现成的库，若用户不知道如何初始化库的一个组件，就往往会出现这一类的错误。清除是另一个特殊的问题，因为用完一个元素后，由于不再关心，所以很容易把它忘记。这样一来，那个元素占用的资源会一直保留下去，极易产生资源（主要是内存）用尽的后果。C++为我们引入了“构建器”的概念。这是一种特殊的方法，在一个对象创建之后自动调用。Java 也沿用了这个概念，但新增了自己的“垃圾收集器”，能在资源不再需要的时候自动释放它们。本章将讨论初始化和清除的问题，以及Java 如何提供它们的支持。 如何正确的开始使用资源和结束使用资源。 4.1 用构建器自动初始化 对于方法的创建，可将其想象成为自己写的每个类都调用一次 initialize()。这个名字提醒我们在使用对象之前，应首先进行这样的调用。但不幸的是，这也意味着用户必须记住调用方法。在 Java 中，由于提供了名为“构建器”的一种特殊方法，所以类的设计者可担保每个对象都会得到正确的初始化。若某个类有一个构建器，那么在创建对象时，Java 会自动调用那个构建器——甚至在用户毫不知觉的情况下。所以说这是可以担保的！ 如果没有写构造器，那么是会存在一个隐含的空参构造器来供自动调用。 接着的一个问题是如何命名这个方法。存在两方面的问题。第一个是我们使用的任何名字都可能与打算为某个类成员使用的名字冲突。第二是由于编译器的责任是调用构建器，所以它必须知道要调用是哪个方法。 C++采取的方案看来是最简单的，且更有逻辑性，所以也在Java 里得到了应用：构建器的名字与类名相同。这样一来，可保证象这样的一个方法会在初始化期间自动调用。 构造器可能会与类中的方法或者属性重名，即使不重名也无法快速的让人或者编译器找到构造器，所以强制构造器和类同名是一个非常好的办法。 请注意所有方法首字母小写的编码规则并不适用于构建器。这是由于构建器的名字必须与类名完全相同！ 这一点确实没注意到过。 构建器属于一种较特殊的方法类型，因为它没有返回值。这与 void 返回值存在着明显的区别。对于void 返回值，尽管方法本身不会自动返回什么，但仍然可以让它返回另一些东西。构建器则不同，它不仅什么也不会自动返回，而且根本不能有任何选择。若存在一个返回值，而且假设我们可以自行选择返回内容，那么编译器多少要知道如何对那个返回值作什么样的处理。 在代码的世界里void只是字面上的空，而不是真正的空，void只是来标识这里为空的符号。 4.2 方法过载 我们用名字引用或描述所有对象与方法。若名字选得好，可使自己及其他人更易理解自己的代码。 人类的大多数语言都具有很强的“冗余”性，所以即使漏掉了几个词，仍然可以推断出含义。我们不需要独一无二的标识符——可从具体的语境中推论出含义。 大多数程序设计语言（特别是C）要求我们为每个函数都设定一个独一无二的标识符。所以绝对不能用一个名为print()的函数来显示整数，再用另一个 print()显示浮点数——每个函数都要求具备唯一的名字。在Java 里，另一项因素强迫方法名出现过载情况：构建器。由于构建器的名字由类名决定，所以只能有一个构建器名称。但假若我们想用多种方式创建一个对象呢？为了让相同的方法名伴随不同的自变量类型使用，“方法过载”是非常关键的一项措施。同时，尽管方法过载是构建器必需的，但它亦可应用于其他任何方法，且用法非常方便。 这里涉及到人类语言和机器语言的很大区别，人类的语言是模糊的，不确定的，为了能肯定一个意思所有需要冗余一部分的内容来让别人更加理解。但是在计算机的世界，0就是0，1就是1，名字是非常确定的。如果想让计算机精确的执行到你指定的方法，那么名字和方法就必须是一一对应的。 但是在一些情况下大家需要在一个固定名字的方法里得到不同的效果，最常见的冲突就是构造器，比如从不同的文件里读取内容来初始化。为此我们就需要让一个函数名可以对应多个函数，这就被称为方法过载。 这本书把这样现象从Overload翻译成过载，还有一种翻译为重载。都是可以接受的翻译。过载说明这个行为是对一个名称加上了多个的含义，就像是汽车过载。重载可以理解为一种重复的载入在一个名称上发生，不过记住这个一个东西就好。后面会接触到重写Overwrite，不要搞混淆了。不少面试题会把这两个词放在一起让你说相同点和不同点，我认为这个非常傻的行为，理解了内在的逻辑区别就很容易明白，这个问题我们后面再说。 4.2.1 区分过载方法 若方法有同样的名字，Java 怎样知道我们指的哪一个方法呢？这里有一个简单的规则：每个过载的方法都必须采取独一无二的自变量类型列表。若稍微思考几秒钟，就会想到这样一个问题：除根据自变量的类型，程序员如何区分两个同名方法的差异呢？ 虽然几个方法使用了一个相同的名字，但是我们还是需要程序执行我们心里指定的效果，所以还是要让程序明白我们需要的是几个重名方法中的哪一个，这里就是依靠方法的参数列表来区分，参数的个数 类型甚至是顺序都会产生影响，执行的可能就是完全不同的两个效果。 4.2.2 主类型的过载 主（数据）类型能从一个“较小”的类型自动转变成一个“较大”的类型。涉及过载问题时，这会稍微造成一些混乱。 给了一串的代码示例，告诉你当参数列表获取的是更小的数据时会自动的进行类型的转换，而把小类型放大类型的位置就需要进行强转。 4.2.3 返回值过载 我们很易对下面这些问题感到迷惑：为什么只有类名和方法自变量列出？为什么不根据返回值对方法加以区分？ 给出的例子说，可能你需要调用一个方法，但是不需要返回值。也有可能你根本就没有接返回值，这种情况下编译器根本没法精确的执行，总不能所有方法的返回值都不能重复吧。 4.2.4 默认构建器 正如早先指出的那样，默认构建器是没有自变量的。它们的作用是创建一个“空对象”。若创建一个没有构建器的类，则编译程序会帮我们自动创建一个默认构建器。 默认构造器，也可以叫他无参构造器。 如果你写了任何一个构造器，编译器就不会给你生成默认构造器。这应该也是为了放置隐形的错误。 如果你只有一个带参数的构造器，那么你在构造方法中加上参数就会导致报错，因为编译器找不到与之对应的构造器。 4.2.5 this 关键字 示例代码说一个类实例化了两次，执行的时候如何知道这里是执行那个类的方法呢。 因为方法的调用是类似：类名.(参数，实例化对象名)，当然这是内部表现的形式，并不能这样写，但是可以这样理解，不理解的话可以看一下如何反射执行一个方法， 假定我们在一个方法的内部，并希望获得当前对象的句柄。由于那个句柄是由编译器“秘密”传递的，所以没有标识符可用。然而，针对这一目的有个专用的关键字：this。 this 关键字（注意只能在方法内部使用）可为已调用了其方法的那个对象生成相应的句柄。可象对待其他任何对象句柄一样对待这个句柄。但要注意，假若准备从自己某个类的另一个方法内部调用一个类方法，就不必使用this。只需简单地调用那个方法即可。当前的this 句柄会自动应用于其他方法。 在方法内部获取对象的引用，在外部就可以直接使用引用名加点的方式了。this关键字更多的是使用在构造器中两个相同名称的变量来做区分。 若为一个类写了多个构建器，那么经常都需要在一个构建器里调用另一个构建器，以避免写重复的代码。可用this 关键字做到这一点。通常，当我们说this 的时候，都是指“这个对象”或者“当前对象”。而且它本身会产生当前对象的一个句柄。在一个构建器中，若为其赋予一个自变量列表，那么 this 关键字会具有不同的含义：它会对与那个自变量列表相符的构建器进行明确的调用。这样一来，我们就可通过一条直接的途径来调用其他构建器。 static 的含义 理解了this 关键字后，我们可更完整地理解 static（静态）方法的含义。它意味着一个特定的方法没有this。我们不可从一个 static方法内部发出对非 static方法的调用。 而且在没有任何对象的前提下，我们可针对类本身发出对一个 static方法的调用。事实上，那正是 static方法最基本的意义。 除了全局函数不允许在Java中使用以外，若将一个 static方法置入一个类的内部，它就可以访问其他static 方法以及static 字段。 有可能发出这类调用的一种情况是我们将一个对象句柄传到static 方法内部。随后，通过句柄（此时实际是this），我们可调用非 static方法，并访问非static 字段。但一般地，如果真的想要这样做，只要制作一个普通的、非static 方法即可。 有些人抱怨 static方法并不是“面向对象”的，因为它们具有全局函数的某些特点；利用 static方法，我们不必向对象发送一条消息，因为不存在this。这可能是一个清楚的自变量，若您发现自己使用了大量静态方法，就应重新思考自己的策略。然而，static 的概念是非常实用的，许多时候都需要用到它。所以至于它们是否真的“面向对象”，应该留给理论家去讨论。 static用起来确实非常方便，导致我经常会给一堆方法都加上static，千万不要学我，被骂过好几次了。 PS，这个主题真的很舒服，写的很开心。 END","link":"/2020/10/15/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E6%9B%B4/"},{"title":"Java编程思想第四更","text":"1.7.1 集合与继承器 针对一个特定问题的解决，如果事先不知道需要多少个对象，或者它们的持续时间有多长，那么也不知道如何保存那些对象。既然如此，怎样才能知道那些对象要求多少空间呢？事先上根本无法提前知道，除非进入运行期。 在面向对象的设计中，大多数问题的解决办法似乎都有些轻率——只是简单地创建另一种类型的对象。用于解决特定问题的新型对象容纳了指向其他对象的句柄。当然，也可以用数组来做同样的事情，那是大多数语言都具有的一种功能。但不能只看到这一点。这种新对象通常叫作“集合”，在需要的时候，集合会自动扩充自己，以便适应我们在其中置入的任何东西。所以我们事先不必知道要在一个集合里容下多少东西。只需创建一个集合，以后的工作让它自己负责好了。 我的理解，数组这种固定长度的数据格式无法满足未知对象类型和数量的情况，这时就自然的创造了集合这个概念。 第二段提到了集合最大和数组的区别，不定长度，不定类型。 所有集合都提供了相应的读写功能。将某样东西置入集合时，采用的方式是十分明显的。有一个叫作“推”（Push）、“添加”（Add）或其他类似名字的函数用于做这件事情。但将数据从集合中取出的时候，方式却并不总是那么明显。如果是一个数组形式的实体，比如一个矢量（Vector），那么也许能用索引运算符或函数。但在许多情况下，这样做往往会无功而返。 此外，单选定函数的功能是非常有限的。如果想对集合中的一系列元素进行操纵或比较，而不是仅仅面向一个，这时又该怎么办呢？ 办法就是使用一个“继续器”（Iterator），它属于一种对象，负责选择集合内的元素，并把它们提供给继承器的用户。作为一个类，它也提供了一级抽象。利用这一级抽象，可将集合细节与用于访问那个集合的代码隔离开。通过继承器的作用，集合被抽象成一个简单的序列。继承器允许我们遍历那个序列，同时毋需关心基础结构是什么——换言之，不管它是一个矢量、一个链接列表、一个堆栈，还是其他什么东西。这样一来，我们就可以灵活地改变基础数据，不会对程序里的代码造成干扰。 吐槽：这为啥一个单词能翻译成两个中文，还都不是现在流行的叫法。最起码Google是翻译成迭代器的。 集合添加元素的方式都很相似，但是获取和修改等操作，因为每个集合各自的数据不同导致不能像数组一样通过一个索引去获取。 为了防止数据结构被破坏，为了维护世界的和平让数据获取有更加统一的获取方式，Java从最开始就对集合类型抽象出了迭代器。有JDBC的感觉。 最后，记住集合只是一个用来放置对象的储藏所。如果那个储藏所能满足我们的所有需要，就完全没必要关心它具体是如何实现的（这是大多数类型对象的一个基本概念）。如果在一个编程环境中工作，它由于其他因素（比如在Windows 下运行，或者由垃圾收集器带来了开销）产生了内在的开销，那么矢量和链接列表之间在系统开销上的差异就或许不是一个大问题。我们可能只需要一种类型的序列。甚至可以想象有一个“完美”的集合抽象，它能根据自己的使用方式自动改变基层的实现方式。 只关心功能，别去想实现。但是面试要问的 改变基层的使用方式我觉得新版的树已经实现了，低冲突的情况下使用数组结果，过多后转为树形结构，兼顾了高效和扩展。 PS：这个星期没看，少更一周","link":"/2020/07/31/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E6%9B%B4/"},{"title":"MyBatis官方文档摘要","text":"MyBatis官方文档摘要 食用声明：仅记录我认为可以用得上的信息，其中包括自我总结（小部分）和官方文档原文（大部分），如须更多内容详见官方文档 入门 其实映射的语句可以不用XML配置，而可以使用Java注解来配置，例如 12345package org.mybatis.example;public interface BlogMapper { @Select(&quot;SELECT * FROM blog WHERE id = #{id}&quot;) Blog selectBlog(int id);} 使用注解来映射诶简单的语句会事代码简洁，但是对于复杂的语句会更加混乱。因此复杂的语句最好还是用XML配置 XML配置 MyBatis的配置文件会深深的影响MyBatis的设置和属性信息，其常用配置如下（摘取部分） 设置（settings） useGeneratedKeys:允许 JDBC 支持自动生成主键，需要驱动支持。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能支持但仍可正常工作（比如 Derby） cacheEnable：全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存 multipleResultSetsEnabled：是否允许单一语句返回多结果集（需要驱动支持） mapUnderscoreToCamelCase：是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射 环境配置（environments） MyBatis可以配置成多种环境，这在现实环境中有多种使用理由，例如，开发 ，测试和生产环境需要不同的配置 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 每个数据库对应一个 SqlSessionFactory 实例 ```JavaSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties); 123456789101112131415161718192021## XML映射文件- MyBatis真正的强大在于它的映射诶语句，它相比有相同功能的JDBC代码相比节约了近95%的代码，MyBatis为聚焦SQL构建，尽可能的减少你的麻烦- SQL映射文件中的定义元素（按照应被定义的顺序列出） 1. `cache` – 对给定命名空间的缓存配置。 2. `cache-ref` – 对其他命名空间缓存配置的引用。 3. `resultMap` – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 4. `parameterMap` – 已被废弃！老式风格的参数映射。更好的办法是使用内联参数，此元素可能在将来被移除。文档中不会介绍此元素。 5. `sql` – 可被其他语句引用的可重用语句块。 6. `insert` – 映射插入语句 7. `update` – 映射更新语句 8. `delete` – 映射删除语句 9. `select` – 映射查询语句### select```XML&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt; SELECT * FROM PERSON WHERE ID = #{id}&lt;/select&gt; 其中#{id}告诉MyBatis创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，类似PreparedStatement ps = conn.prepareStatement(selectPerson); 默认情况下,使用 #{} 格式的语法会导致 MyBatis 创建 PreparedStatement 参数占位符并安全地设置参数（就像使用 ? 一样）。 这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL 语句中插入一个不转义的字符串。 比如，像 ORDER BY，你可以这样来使用：ORDER BY ${columnName} 用这种方式接受用户的输入，并将其用于语句中的参数是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler） 推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。请使用内联参数映射和 parameterType 属性。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。 fetchSize 这是一个给驱动的提示，尝试让驱动程序每次批量返回的结果行数和这个设置值相等。 默认值为未设置（unset）（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 中的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用。它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。 insert，update和delete：和SQL中的同名语句实现非常接近，不再赘述sql 这个元素可以被用来定义可重用的 SQL 代码段，这些 SQL 代码可以被包含在其他语句中。它可以（在加载的时候）被静态地设置参数。 在不同的包含语句中可以设置不同的值到参数占位符上 1&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt; 1234567&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;, &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; 结果映射 resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的长达数千行的代码。ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。 12345&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt; select id, username, hashedPassword from some_table where id = #{id}&lt;/select&gt; 假设具有一个User类，类中有三个属性：id，username和hashedPassword，这样的一个JavaBean可以被映射到ResultSet 12345&lt;select id=&quot;selectUsers&quot; resultType=&quot;com.someapp.model.User&quot;&gt; select id, username, hashedPassword from some_table where id = #{id}&lt;/select&gt; ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。 上面这些简单的示例根本不需要下面这些繁琐的配置。 但出于示范的原因，让我们来看看最后一个示例中，如果使用外部的 resultMap 会怎样，这也是解决列名不匹配的另外一种方式。 12345&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot; /&gt; &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;&lt;/resultMap&gt; 而在引用它的语句中使用 resultMap 属性就行了（注意我们去掉了 resultType 属性）。比如: 12345&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt; select user_id, user_name, hashed_password from some_table where id = #{id}&lt;/select&gt; 如果世界总是这么简单就好了。 缓存 MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。 默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：&lt;cache/&gt; 基本上就是这样。这个简单语句的效果如下: 映射语句文件中的所有 select 语句的结果将会被缓存。 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。 缓存不会定时进行刷新（也就是说，没有刷新间隔）。 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。 动态SQL MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 if12345678&lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt;&lt;/select&gt; 这条语句提供了一种可选的查找文本功能。如果没有传入“title”，那么所有处于“ACTIVE”状态的BLOG都会返回；反之若传入了“title”，那么就会对“title”一列进行模糊查找并返回 BLOG 结果（细心的读者可能会发现，“title”参数值是可以包含一些掩码或通配符的）。 choose，when，otherwise 有时我们不想应用所有条件语句，这时可以使用choose元素，它有点像Java中的switch 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; foreach 动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如： 123456789&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #{item} &lt;/foreach&gt;&lt;/select&gt; foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及在迭代结果之间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。 注意 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 Java API：MyBatis目录结构，SqlSessions 使用 MyBatis 的主要 Java 接口就是 SqlSession。你可以通过这个接口来执行命令，获取映射器和管理事务。我们会概括讨论一下 SqlSession 本身，但是首先我们还是要了解如何获取一个 SqlSession 实例。SqlSession 是由 SqlSessionFactory 实例创建的。SqlSessionFactory 对象包含创建 SqlSession 实例的所有方法。而 SqlSessionFactory 本身是由 SqlSessionFactoryBuilder 创建的，它可以从 XML、注解或手动配置 Java 代码来创建 SqlSessionFactory。 注意 当 Mybatis 与一些依赖注入框架（如 Spring 或者 Guice）同时使用时，SqlSession 将被依赖注入框架所创建，所以你不需要使用 SqlSessionFactoryBuilder 或者 SqlSessionFactory，可以直接看 SqlSession 这一节。请参考 Mybatis-Spring 或者 Mybatis-Guice 手册了解更多信息。 SQL语句构建器类 Java程序员面对的最痛苦的事情之一就是在Java代码中嵌入SQL语句。这么来做通常是由于SQL语句需要动态来生成-否则可以将它们放到外部文件或者存储过程中。正如你已经看到的那样，MyBatis在它的XML映射特性中有一个强大的动态SQL生成方案。但有时在Java代码内部创建SQL语句也是必要的。此时，MyBatis有另外一个特性可以帮到你，在减少典型的加号,引号,新行,格式化问题和嵌入条件来处理多余的逗号或 AND 连接词之前。事实上，在Java代码中来动态生成SQL代码就是一场噩梦。 MyBatis 3提供了方便的工具类来帮助解决该问题。使用SQL类，简单地创建一个实例来调用方法生成SQL语句。 1234567891011121314151617181920private String selectPersonSql() { return new SQL() {{ SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;); SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;); FROM(&quot;PERSON P&quot;); FROM(&quot;ACCOUNT A&quot;); INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;); INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;); WHERE(&quot;P.ID = A.ID&quot;); WHERE(&quot;P.FIRST_NAME like ?&quot;); OR(); WHERE(&quot;P.LAST_NAME like ?&quot;); GROUP_BY(&quot;P.ID&quot;); HAVING(&quot;P.LAST_NAME like ?&quot;); OR(); HAVING(&quot;P.FIRST_NAME like ?&quot;); ORDER_BY(&quot;P.ID&quot;); ORDER_BY(&quot;P.FULL_NAME&quot;); }}.toString();} end","link":"/2020/06/22/MyBatis%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%91%98%E8%A6%81/"},{"title":"Spring笔记01","text":"Spring笔记01 Spring快速上手+IOC+注解 01. Spring共四天 第一天:spring框架的概述和spring中基于XML的IOC配置 第二天:基于注解的IOC和IOC的案例 第三天:spring中的aop和基于XML和注解的AOP配置 第四天;spring中的JDBCTemlate以及Spring事务控制 02.今天课程内容概述 spring的概述 spring是什么 spring的两大核心 spring的发展经历和优势 spring的体系结构 程序的耦合以及解耦 IOC概念和spring中的IOC spring中基于XML的IOC环境搭建 依赖注入(Dependency Injection) 作业 03.Spring概述 Spring是分层的Java SE/EE的应用 full-stack轻量级开源框架,以IoC(inverse Of Control) 和 AOP(Aspect Oriented Programming:面向切面编程) 为内涵,提供了展现层SpringMVC和持久层Spring JDBC以及业务层事物管理等众多的企业级应用技术. 04.Spring的发展历程 Rod Johnaon(spring之父) 2017-9发布了spring的最新版spring5.0通用版 05.Spring的优势 方便解耦,简化开发 AOP编程的支持 声明式事物的支持 方便程序的测试 方便集成各种优秀框架 降低JavaEE API的使用难度 Java源码是经典学习范例 06.Spring的体系结构 源码结构 docs 文档 libs jar包 schema 约束 Core Container:核心容器,必须存在 07.编写jdbc的工程代码用于分析程序的耦合 jdbc 注册驱动 获取连接 获取操作数据库的预处理对象 执行SQL,得到结果集 遍历结果集 释放资源 08.编译期依赖 如果一个类中需要使用一个jar包,没有的话编译期就会失败,这就可以理解为程序的耦合 09.程序的耦合和解耦的思路分析 耦合:程序之间的依赖关系 类之间的依赖 方法间的依赖 解耦:降低程序之间的依赖关系 实际开发中:编译器不依赖,运行时才依赖 解耦的思路 第一步:使用反射创建对象,而避免new关键字 第二步:通过读取配置文件来获取要创建的对象全限定类名 10.曾经代码中的问题分析 在表现层new的service层的类,在service中new的dao类,具有高耦合性 11. 编写工厂类和配置文件 Bean:在计算机英语中,有可重用组件的含义. javabean != 实体类 javabean&gt;实体类 解耦 一个配置文件来配置service和dao 配置都得内容:唯一标识=全限定类名(key=value) 通过读取配置文件的内容,反射创建对象 12.工程模式解耦 在properties获取输入流时,不要使用new输入流,因为不能保证可以复用,使用BeanFactory.class.getClassLoader().getResourceAsStream(“bean.prperties”) 13.分析工厂模式的问题并改造 之前的工厂是多例的,如果是单例,类只被创建一次,类属性也就被初始化一次. 定义一个Map,用来存放我们要创建的对象,把它称为容器 14.工厂模式解耦的升级版 将查找到的Bean中存入Map,修改get方法为return map.get 15.IoC的概念和作用 控制反转,把创建对象的权利交给框架,是框架的重要特征,并非面向对象编程的专用术语.它包括依赖注入(DI)和依赖查找(Dependency Lookup) IoC的作用:削减计算机程序的耦合(解除我们代码中的依赖关系) 16.Spring的IoC的前期准备 只能解耦,不能消除,只能降低依赖 下载开发包 https://spring.io/ 17.Spring基于XML的IOC环境的搭建和入门 导入maven坐标 new xpt getBean 18.ApplicationContext的三个实现类 ApplicontionContext的三个常用实现类 ClassPathXmlApplicationContext 加载类路径下的配置文件,要求配置文件必须在类路径下 FileSystemXmlApplicationContext 加载磁盘任意路径下的配置文件(必须有访问权限) AnnotationFigApplicationContext 用于读取注解创建容器 19.BeanFactory和ApplicationContext的区别 ApplicationContext: 创建容器时,参加对象采用的策略是采用立即加载的法师,只要一读取完配置文件马上就创建配置文件中的配置的对象 单例对象运用 因为是子接口,所以更常用 BeanFactory: 采用延迟加载的方式,根据id获取对象了,才真正的创建对象 多例对象运用 20.Spring中的细节之三种创建Bean对象的方式 创建bean的三种方式(当需要的类存在与jar包中,又没有提供无参的构造函数,又因为无法修改源代码,就可以使用二三的方法) 使用默认构造函数创建,在spring的配置文件使用bean标签,配以id和class属性后,且没有其他属性和标签时.采用的就是默认构造函数创建bean对象,此时如果类中没有默认构造函数,则对象无法创建 使用普通工程的方法创建对象(使用某个类中的方法创建对象,并存入spring容器) factory-bean=”instanceFactory factory-method=”getAccountService” 使用静态工厂中的静态方法创建对象(使用某个类中的静态方法创建对象,并存入spring容器) class=”工程全类名” factory-method=”getAccountService” bean对象的作用范围 bean对象的生命周期 21.Spring中的细节之作用范围 bean的作用范围的调整 scope属性 用于指定bean的作用范围 singleton:单例(默认值) prototype:多例 request:作用于web应用的请求范围 session:作用于web应用的会话范围 global-session:作用于集群环境的会话范围(全局会话范围),当不是集群的环境时它就是session 22.spring中的细节之生命周期 Bean的生命周期 单例对象 容器创建时出生 容器还在,对象一直活着 容器销毁,对象消亡 总结:单例对象的生命周期和容器相同 多例对象 当使用对象时创建 对象只要在使用中一直存在 当对象长时间不用,且没有其他对象引用时,由gc回收 23.spring的依赖注入 spring的依赖注入 Dependency Injection 依赖注入 依赖关系的维护都交给spring类维护,在当前类中使用到其他类的对象,由spring为我们提供,我们只需要在配置文件中说明 依赖关系的维护就称之为依赖注入 依赖注入: 能注入的数据 基本类型和string 其他bean类型(在配置文件中或注释配置过的bean) 复杂类型/集合类型 注入的方式有三: 使用构造函数提供 使用set方法提供 使用注解提供 24.构造函数注入 构造函数注入 如果是经常变化的数据,不适合注入 * 出现在bean标签的内部 * 标签中的属性 * type:用于指定要注入的数据的数据类型,该数据类型也是构造函数中某个或某些参数的类型 * index:指定要注入的数据给构造函数中指定索引的参数赋值,索引的位置从0开始 * name:用于指定个体构造函数指定名称的参数赋值 * value:用于提供基本类型和string类型的数据 * ref:用于指定其他bean类型的数据,它就是指在spring的ioc核心容器中出现过的bean对象 * 优点:在获取bean对象时,注入数据是必须的操作,否则对象无法创建成功 * 弊端:该变了bean对象的实例化方式,使我们在创建对象时即使不使用的数据也必须提供 25.set方法注入(更常用) set方法注入 property 出现在bena标签的内部 标签的属性 name:用于指定注入时所调用的set方法名称 value ref 优势:创建对象时没有明确的限制,可以直接使用默认构造函数 弊端:如果某个成员必须有值,则对象的set方法可能没有执行 26.注入集合数据 用于给LIst集合注入的标签 list array set 用于给Map结构注入的标签 map props 结构相同,标签可以互换 27.课程知识梳理 预习注解 28.今日课程内容介绍 spring中ioc的采用注解 案例使用xml方式和注解方式实现单表的CRUD的操作 持久层技术选择:dbutils 改造基于注解的ioc案例,使用纯注解的方式实现 spring中的一些新注解的使用 spring和Junit整合 29.采用IOC注解按照作用分类 在类中添加注解实现解耦 分类 用于创建对象的 与xml中的bean功能相同 用于注入数据的 bean标签中property标签的功能相同 用于改变作用范围的 bean中scope标签功能相同 和生命周期相关的 bean中init-method和destroy-method的作用相同 30.用于创建的Component注解 作用:用于把当前类存入spring容器中 属性: value:用于指定bean的id.当我们不写,它的默认值为当前类名,并且首字母小写 需要告知spirng在创建容器时要扫描的包,配置所需要的标签不是在beans的约束中,而是名称为context名称空间和约束中 &lt;context:component-scan base-package=”com.itheima”/&gt; 注解中只有一个value可以不写value 31.由Component衍生来的注解 Controller:一般用于表现层 Service:一般用于业务层 Repository:一般用于持久层 以上三个注解的作用和属性和Component是一模一样的,它们三个是一模一样的,它们三个是spirng框架为我们提供明确的三层使用的注解,使我们的三层对象更加清晰 32.自动按照类型注入 AutoWired: 作用: 自动按照类型注入,只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配,就可以注入成功 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配,报错 如果ioc容器中有多个匹配的类型,先匹配类型,相同则再比骄傲变量名,相同则可以注入,不同则报错 出现位置: 可以是变量,也可以是方法上 细节: 在使用注解注入时,set方法就不是必须的 33. 用于数据注入的注解 Qualifier 作用:在按照类中注入的继承上再按照名称注入,它在给类成员注入时不能单独使用,但是给方法参数注入时可以 属性 value:用于指定注入bean的id Resource 作用:注解按照Bean的id注入,它可以独立使用 属性: name:用于指定bean的id 以上三个注入都只能注入其他bean类型的数据,而基本类型和string类型无法使用上述注解实现,另外集合类型的注入只能通过XML实现 value 作用:用于注入基本类型和string的类型 属性: value:用于指定数据的值,它可以使用spring中SpEL(也就是spring的el表达式) SpEL的表达式:${表达式} 2019/12/24 20:47","link":"/2020/06/22/Spring%E7%AC%94%E8%AE%B001/"},{"title":"Windows软件分享","text":"自己的Windows常用软件分享 食用说明：仅代表个人观点，请酌情使用。加粗的为重点推荐。 懒人并不想传图了。。。 这篇文给我搞吐了，怎么都不能渲染，等我搞明白了再说。 Browser MicroSoft Edge：新edge的无缝同步还是很香的，目前已经完全迁移过来了，多端同步还是挺舒服的。PS：ios端我用不惯，还是Safari好用。 浏览器插件推荐 Dark Reader：网页黑暗模式。 Evernote Web Clipper：剪切网页到印象笔记。 RSSHub Radar：查找当前页面的rss地址。 Raindrop.io：保存文章。 Tampermonkey：油猴脚本应该都知道。 smartUp手势：网页手势。 uBlock Origin：很好用的广告屏蔽。 图片助手(ImageAssistant) 批量图片下载器：好像没啥用但还是装了。 沙拉查词-聚合词典划词翻译：查单词。 简悦 - SimpRead：看文章，尤其是csdn和cnbolg上的文章，默认格式辣眼睛。 OneTab：快速保存标签。 Stylus：配置网页格式，用的最多的是来去广告。 Toby for Chrome：以前当书签用，现在当桌面用。 Vimium：敲键盘就能浏览网页，很酷。 下载+：很小巧的下载管理。 Daily Eclipse：吃饭的家伙。不要问我为什么不用idea，还不是穷，另外就是用习惯了 VScode：简单好看的编辑器，我基本什么文件都用这个看。 DBeaver：数据库管理工具，因为开源免费和同eclipse一致的快捷键而使用。其中的SQL格式化非常好用。 Postman：API工具，简单好用。 Input SumatraPDF：一直在用的PDF阅读器，开源免费简单好用。 Output Typora：MarkDown最强编辑器，没有之一，我的所有博客都是用这个写的。 印象笔记：很老牌的工具了，用了也有七八年了，但是一直不顺心，不知道是不是自己的原因。 Notion：全新的笔记工具，模块化的设计和各种视图的搭配真的爱了。尤其是全用户免费就很舒服。缺点是随时有被和谐的可能。 Hexo+GitHub：我的博客套餐。 Tool Snipaste：只用这个截图，功能一应俱全。 Oracle VMBox：免费的虚拟机工具，小巧设置简单，就是配套的教程不是很多。 坚果云：同步工作文档非常好用，在我搞坏一个五千行的EXCEL之后就知道这个有多重要了。 QT bar：用了很久了，让我都快忘记它的存在。增强系统文件夹管理，最近打开文件很好用。 腾讯桌面整理：免费，无广告，功能还不错，推荐一试。 Geek：卸载工具，免费小巧方便。 FolderSize：文件夹占用分析。 SpaceSniffer：另一款文件大小分析，会以小方块的形式展示文件占用比例。 noMeiryoUI：一键更换系统字体，刚刚才发现我的字体被换回去了，之前用的等距更纱黑体。 jd-gui：看jar文件里的源代码，缺点是大小很奇怪在4k屏幕上。 Rime（小狼毫）：唯一使用的输入法，配置好后非常舒服，建议尝试。有机会写一篇配置上手。 Calibre：屯书癖必备，我已经出院不需要了。 End","link":"/2020/07/29/Windows%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"},{"title":"WSL尝鲜-Ubuntu安装与环境部署","text":"前言 标题是尝鲜，其实是好几年前的东西了，不过在体会到虚拟机的费劲之后，还是来试一下这个好不好用，几个小时的体验感觉还可以，下面我来介绍一下如何吃上这老螃蟹。 安装 [先贴上官方的安装教程]: https://docs.microsoft.com/zh-cn/windows/wsl/install-win10 我为了省事安装的就是WSL1，WSL2在虚拟化方便是具有更好的效果，例如docker等， 在Windows商店下载Linux发行版，其中有Ubuntu和Ubuntu LTS ，我选择了第一个，下载了之后也是LTS版本。暂时不支持（最起码在我的电脑上）不支持安装到c盘以外的盘，对本就不富裕的c盘又雪上加霜。安装之后就可以愉快的玩耍啦。 准备工作 上手之后第一步当然是换源啦，我选择的是中科大的， 1sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list 检查是否替换成功查看：/etc/apt/sources.list 最后更新一下：sudo apt-get update 小插曲：关于apt-get和apt的区别 简单来说apt-get是跟老的工具，apt是一种跟简单的工具，跟容易上手，也更容易使用。所以推荐使用apt，但是在某些情况下apt无法使用，这个时候还是需要apt-get的。 安装Java81sudo apt install openjdk-8-jdk 剩下的环境我也还没装，等我装了之后再更新一下","link":"/2020/06/30/WSL%E5%B0%9D%E9%B2%9C-Ubuntu%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"title":"Java基础知识复习","text":"本文为记录从java基础开始中遇到的难点及盲点,供复习与参考使用 Java中实现多态的机制 靠父类活接口的引用类型指向子类或实现类的实例对象,程序调用的方法才在运行期动态绑定,就是引用变量所指向的具体实例对象的方法,就是内存中正在运行的对象的方法,而不是变量中类型定义的方法. synchronized和java.util.concurrent.locks.Lock的异同 Lock能完成synchronized所实现的所有功能 不同:Lock比synchronized更精确的线程语义和更好的性能.synchronized会自动释放锁,而Lock一定要求手动释放.并且在finally从句中释放. HashMap和HashTable的区别 HashTable继承Dictionary类,HashMap是Map接口的实现 HashTable是线程安全的,HashMap是线程不安全的 HashMap可以使用null作为value或key 什么类型类在switch语句中使用 比int小的类型都可以隐式转换为String,都是可以的,但是大于int的都不行 final修饰变量,是引用不能变,还是引用的对象不能变 是引用变量不能变,引用指向的对象的内容还是可以改变的. 深拷贝和浅拷贝 使用clone()方法,基本类型是复制值,引用是复制地址,所以指向了相同的对象,此为浅拷贝. 如果需要重新创建对象需要实现Cloneable接口,,实现clone方法.被引用的对象也必须实现Cloneable接口并实现clone方法. 下列Integer类型数值的比较输出的结果123Integer f1 = 100,f2 = 100,f3 = 150,f4 = 150;f1 == f2;f3 == f4; 在Integer源码中如果字面量在-128到127之间就不会new新的Integer对象,而是直接使用常量池中的对象,所以结果为treu,false Map Map 接口有三个实现类（HashMap：基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null 值和 null 键；HashTable：线程安全，低效，不支持 null 值和 null 键；LinkedHashMap：是 HashMap 的一个子类，保存了记录的插入顺序；SortMap 接口：TreeMap，能够把它保存的记录根据键排序，默认是键值的升序排序）。 两者的key值均不能重复,若添加key相同的键值对,后面的value会覆盖前面的value 创建的线程池 在java.util.concurrent.Executors提供了生产多线程池的静态方法 newSingleThreadExecutor:创建一个单线程的线程池,此线程池保证所有的任务的执行顺序按照的任务的提交顺序执行 newFixedThreadPool:创建固定大小的线程池,每次提交一个认为就创建一个线程,直到线程达到线程池的最大容量 newCachedThreadPool:创建一个可缓存的线程池,此线程池不会对线程池的大做限制,待笑傲完全依赖jvm能够创建的最大线程大小 newScheduledThreadPool:创建一个大小无限的线程池,此线程池支持定时以及周期性执行任务的需要 newSingleThreadExecutor:创建一个单线程线程,此线程支持定时及周期性执行任务的要求 以Pool结尾的为线程池,以Executors结尾的为线程执行器 进程和线程的区别 进程:具有一定孤立功能的程序关于每个数据集合上的一次运行活动,是操作系统资源调度和分配的一个独立单位 线程:是线程的一个实体,是cpu调度和分配的基本单位,是比进程更小的可以独立运行的基本单位 特点:线程的划分尺度小于进程,这使得多线程程序拥有高并发性,进程在运行时各自内存单元相互独立,线程之间内存共享, 工程模式 普通工程模式 根据传入的条件判断后返回不同的实例,不返回添加则不返回实例 静态工程模式 将工程方法中的方法置为静态,不需要创建工程类实例 抽象工厂模式 工厂方法如果休要添加新的类则要修改工程类,违背了闭包的原则,可以使用抽象工程模式,创建多个工程类,有新功能直接添加新的工程类就可以 建造者模式(Builder) 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的 Test 结合起来得到的。 我的理解:在一个类中将不同类的属性拼接整合后返回 适配器设计模式 适配器将某个类的接口转换为客户端期望的另一个接口表示,目的是消除接口不匹配造成的类的兼容性问题,主要有:类的适配器模式,对象的适配器模式,接口的适配器模式. 类的适配器模式:一个类继承了一个类实现了一个接口.在接口中定义了一个新的方法. 对象的适配器模式,基本思路与类的适配器基本相同,只是不在继承类,而是持有父类的实例 接口的适配器模式:我们写的一个接口中有多个抽象方法,当我们写该接口的实现类时,必须实现该接口的所有方法,这有时是浪费的,为了解决这个问题我们借助于一个抽象类,该抽象类实现了该接口,实现了所有的方法,而我们不与原始的接口打交道,继承抽象类,重写需要的方法. 装饰模式(Decorator) 装饰模式就是给一个对象增加一些新功能,而且是动态的,要求装饰对象和被装饰对象实现同一个接口,装饰对象持有被装饰对象的实例 我的理解:一个接口其中有一个方法,a类实现了接口,b也实现了接口,并在其内部创建了a,在自己的构造中要求传入a类,并将其赋值给自己的局部变量.在b类中重写接口中的方法,在方法中添加需要装饰的功能,并且调用了a类的方法.在测试类中,首先new a类,传入b类的构造中获得一个b类,在b类中调用接口中的方法,此方法就是b类中写的方法,实现了动态修改a类中方法的效果. JVM垃圾回收机制和常见算法 不同的厂商的JVM采用的算法不尽相同. 如何发现无用的对象,采用的搜索算法如下: 引用计数器:每个对象应用时计数器+1,应用失效时-1.该算法简单效率高,但是无法判断循环引用的问题,所以此算法不再被使用 根搜索算法 根搜索算法是通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（Reference Chain），当一个对象没有被 GC Roots 的引用链连接的时候，说明这个对象是不可用的 GC Roots 对象包括： 虚拟机栈（栈帧中的本地变量表）中的引用的对象。 方法区域中的类静态属性引用的对象。 方法区域中常量引用的对象。 本地方法栈中 JNI（Native 方法）的引用的对象。 JVM中的内存结构和内存分配java虚拟机将管辖的内存大致分为三个部分:方法区,java栈,java堆 方法区是静态的,编译器将变量绑定在某个位置上,并且这些绑定在运行不会改变.例如:常量池,源代码中的命名常量,string的常量,static变量存储在方法区 java stack是一个逻辑概念,特点是后进先出,一个栈可能是连续的,也可能是不连续的.最典型的Stack应用是方法的调用,java虚拟机每调用一次方法就创建一个方法栈,退出时方法对应的方法栈被弹出(pop) java堆分配(heap allocation)意味着以任意的顺序,在运行时进行存储空间分配和回收的内存管理. Java中引用类型都有那些(重要) java中对象的引用分为四种级别,从高到低分为:强引用,软引用,弱引用和虚引用 Java 的对象是位于heap 中的，heap 中对象有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到达对象。应用的强弱顺序是强、软、弱、和虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。 1234String abc=new String(&quot;abc&quot;); SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(abc); WeakReference&lt;String&gt; weakRef = new WeakReference&lt;String&gt;(abc); abc=null; softRef.clear(); 第一行的对象是强引用,是强可及的 第二行创建对象的软引用和弱引用,对象仍然是强可及的 第四行后对象不再是强可及,变成软可及的 第五行执行后变成软可及 区别 强引用:如果一个对象被被人拥有强引用，那么垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 软引用:如果一个对象只具有软引用，那么如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 弱引用:如果一个对象只具有弱引用，那该类就是可有可无的对象，因为只要该对象被 gc 扫描到了随时都会把它干掉。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过， 由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 虚引用:”虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。","link":"/2020/06/22/java%C2%9FJ%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"},{"title":"Spring笔记02","text":"35.测试基于XML的IOC案例 在xml配置service和dao,在IOC中实现增删改查 36.测试基于XML的IOC案例之编写spring的ioc配置 在XML中配置注入 bean service property name ref bean dao property name ref bean runner constructor-arg ref bean dataSource property driver … jdbcUrl … user … password 37.测试基于XML的IOC案例之案例准备38.注解IOC案例-把自己编写的类使用注解配置 只有唯一对象,使用autowired可以没有set,为什么 @Repository @Autowired &lt;context:component-scan base-package=”cn.tedu.test”/&gt; 测试 39.Spring的新注解-Configuration和componentScan如何解决xml文件和注释同时存在,并且查询数据库语句冗余的问题 @Configuration 作用:指定当前类是一个配置类 @ComponeentScan 作用:用于通过注解指定spring在创建容器时要扫描的包 属性 value:用于指定创建容器时要扫描的包,与basePackages的作用一样 40.Spring的新注解-Bean @Bean 作用:把当前方法的返回值当作bean对象存入spring的ioc容器中 属性 name:用于指定bean的id,默认值为当前方法的名称 细节 如果使用注解配置方法时,如果方法有参数,那么spring会去容器中查找有没有可用的bean对象,查找方式和autowired注释的一样 41.AnnotaionConfigApplicationContext 删除xml文件后就不能再使用ClassPathXmlApplicationContext,使用AnnotaionConfigApplicationContext.构造中传入配置类的字节码文件 细节:此时的Bean为单例,如果需要多例则要添加@Scope(“prototype”) 42.Spring的新注解-Import Configuration 细节:当配置类作为AnnotationConfigApplicationContext对象创建的参数时,该注解可以不写 但是,如果在AnnotaionConfigApplicationContext的构造中不传入字节码文件,则必须要写 @Import 作用:用于导入其他的配置类 属性: value:用于指定其他配置的字节码,当我们使用其他import的注解后,有import注解的类就是父配置类,导入的都是子配置类. 使用了该注释后,就可以不用在scan中添加,不用在Annotaion的构造中传入,也不需要在类中声明为配置类 43.Spring的新注解-PropertySource @PropertySource @PropertySource(“classpath:jdbcConfig.properties”) 作用:用于指定properties文件的位置 属性 value:指定文件的名称和路径 关键字:classpath:表示在类路径下 实际开发中,推荐使用xml和注解混合的开发方式,如果使用jar包中类,使用xml更好.自己开发的类使用注解更加方便44.Qualifier注解的另一种用法 在方法的参数中使用来指定在一个类中两个Bean的分别使用 45.Spring整合之junit问题分析 可以使用@Before来解决代码重复初始化的问题,但是在实际开发中初始和测试是分开的工作,测试工程师可能不知道如何初始化, junit单元测试中,没有main方法也可以执行,junit集成了一个main方法,该方法会判断当前测试类中那些方法有@Test注解,junit就会让Test注解的方式执行 junit不会管我们是否采用了spring框架,在执行方法时,junit根本不知道我们是不是使用了spring框架,所以也就不会读取配置文件或配置类创建spring核心容器 当测试方法执行时,没有Ioc容器,就算写了autowired也不可以 46.Spring整合junit 导入spring整合junit的jar包坐标&gt;spring-test 使用junit提供了注解把原有的main方法替换,替换成spring提供的 @Runwith 加在类上@Runwith(SpringJUnit4ClassRunner.class) 告知spirng的运行器,spring和ioc创建是基于xml还是注解的,并且说明位置 @ContextConfiguration 加载类上@ContextConfiguration(classes=SpringConfiguration.class) Location:执行xml文件的位置,加上classpath关键字,表示在类路径下 classes:指定解析类的位置 当使用spring5.x的版本时,要去junit的jar必须是4.12及以上 此报错只有在run类时才会出现","link":"/2020/06/22/Spring%E7%AC%94%E8%AE%B002/"},{"title":"《JavaScript Good Parts》附录书摘","text":"第十章:Beautiful Features 提炼JavaScript的子集,这样我就不用解析整个语言,并且也就不需要描述整个语言了,我把这个语言叫做精简的JavaScript(Simplified JavaScript). 精简的JavaScript中都是好东西,包括一下主要的内容 函数时顶级对象 在精简的JavaScript中,函数是有语法作用域的闭包(lambda); 基于原型继承的动态对象 对象是无类型的,我们可以通过普通的赋值给如何对象添加一个新的成员属性.一个对象可以从另一个对象继承成员属性 对象字面量和数组字面量 这对创建新的对象和数组来说是一种非常方便的表示法,JavaScript字面量是数据交换格式JSON的灵感来源 附录A:Awful Parts 在本附录中,我会展示JavaScript的一些难以避免的问题特性,你必须知道这些问题并准备好对应的措施. 全局变量 Global Variables 在JavaScript所有的糟糕特性之中,最为糟糕的一个就是它对全局变量的依赖.全局变量就是在所有作用域中都可见的变量.全局变量就是在所有作用域中都可见的变量.全局变量在小型程序中可能会带来方便.因为一个全局变量可以在程序的任何部分在任何时间修改,它们使得程序的行为变的极度复杂.在程序中使用全局变量降低了程序的可靠性. 全局变量使得在同一个程序中运行独立的子程序变得更难.如果某些全局变量的名称碰巧和子程序中的变量名相同.那么它们会互相冲突,可能导致程序无法运行,而且通常难以调试. 作用域 Scope JavaScript的语法来源于C.在所有其他类似C语言风格的语言里,一个代码块会创造一个作用域.代码块中声明的变量在其外部是不可见的.JavaScript采用了这样的块语法,却没有提供块级作用域:代码块声明的变量在包含次代码块的任何位置都是可见的. 在大多数语言中,一般来说,声明变量的最好地方是第一次用到它的地方.但这种做法在JavaScript中反而是一个坏习惯,因为它没有块级作用域.更好的方式是在每个函数的开头部分声明所有变量. 自动插入分号 Semicolon Insertion JavaScript有一个自动修复机制.它试图通过自动插入分号来修正有缺陷的程序.但是,千万不要指望它,它可能会掩盖更为严重的错误. 有时它会不合时宜的插入分号.请考虑在return语句中自动插入分号而导致的后果.如果在一个return语句返回一个值.这个值表达式的开始部分必须和return在同一行. 1234return { status:true }; 这看起来是要返回一个包含status成员元素的对象.遗憾的是,自动插入分号让它成为了返回undefined.自动插入分号导致程序被误解,却没有任何警告提醒.如果把( 放在上一行的尾部而不是下一行的头部可以避免该问题. 保留字 Reserved Words 下面的单词在JavaScript中被保留 abstract boolean break byte case catch char class const continue debugger default delete do double else enm export extends false final finally float for function goto if implements import in instanceof int interface long native new null package private protected public return short static super switch synchronized this throw throws transient true try typeof var volatile void while with 这些单词的大多数并没有在语言中使用 它们不能被用来命名变量或函数,当保留字被用做对象字面量的键值时,它们必须被引号括起来.它们不能被用在点表示法中,所以有时必须使用括号表示法: var method; //ok var class; //非法 object ={boc:value}; //ok object = {case: value}; //非法 object = {‘case’ :value}; // ok object.box = value; //ok object.case = value; //非法 object[‘case’] = value; //ok typeof typeof运算符返回一个用于识别其运算数类型的字符串所以: typeof 98.7 ,返回’number’,遗憾的是 typeof null返回’object’而不是’null’,这太糟糕了.其实有更简单也更好的检查null的方式: my_value === null parseInt parseInt是一个把字符串转为整数的函数.它在遇到非数字会停止解析.所有parseInt(“16”)与parseInt(“16 tons”)产生相同的结果.但是该函数会提醒我们出现了额外额文本就好了,但它不会那么做. 那么该字符串第一个字符是0,那么该字符串会基于八进制而不是十进制来求值,在八进制中,8和9不是数字,所以parseInt(“08”)和parseInt(“09”)都产生0转为结果,这个错误会导致程序解析日期和时间时出现问题.幸运的是,parseInt可以接受一个基数转为参考,如此一来parseInt(“08”,10)结果为8,我建议你总是加上一个基数参数 + +运算符可以用于加法运算或字符串连接.它究竟会如何执行取决于其参数的类型.如果其中一个字符串是空字符串,它会把另一个运算符转换成字符串并返回.如果两个运算符都是数字,它返回两者之合.否则,它把两个运算符都转为字符串并连接起来.这个复杂的行为是bug的常见来源.如果你要使用+去做加法运算.请保证两个运算数都是整数. 浮点数 Floating Point 二进制的浮点数不能正确的处理十进制的小数,因此0.1+0.2不等于0.3.这是JavaScript中最经常被报告的bug,并且它是遵循二进制浮点数算术标准(IEEE 754)而有意导致的结果.但是它违背了大多数你在中学中学到的关于数学的知识.幸运的是,浮点数中的整数运算是精准的,所以小数表现出来的错误可以通过指定精度来避免 NaN NaN是IEEE中定义的一个特殊的数量值.它表示的不是一个数字,尽管下面的表达式返回的是true: typeof NaN === ‘number’//true 如果NaN是属性运算中的一个运算数,那么结果就是NaN.所以,如果你有一个公式链产生了NaN的结果,那肯定是其中某一个输入项是NaN,要么在某个地方产生了NaN 你可以对NaN进行检测,typeof不能识别数字和NaN,而且NaN不等于它字节.所以下面的代码结果让人惊讶: NaN === NaN //false NaN != NaN //true ps:此处黑人问号 javaScript中提供了一个isNaN函数,可以分辨数字和NaN 伪数组 Phony Arrays JavaScript没有真正的数组,这也不全是坏事.JavaScript的数字确实非常容易使用,你不必给它们设置维度,而且它们永远不会产色越界错误,但是它们的性能相比真正的数组可能相当糟糕. typeof运算符不能辨别数组和对象.要判断一个值是否为数组,你还需要检查它的constructor属性 if (my_value &amp;&amp; typeof my_value === ‘object” &amp;&amp; my_value.constructor === Array) 假值 Falsy Values JavaScript拥有一组数量齐大的假值 值 类型 0 number NaN(非数字) number “”(空字符串) String false Boolean null Object undefined Undefined 这些值全部都等同于假,但是它们是不可互换的 Object JavaScript的对象永远不会是真的空对象.因为它们可以从原型链中取得成员属性","link":"/2020/06/22/%E3%80%8AJavaScript%20Good%20Parts%E3%80%8B%E9%99%84%E5%BD%95%E4%B9%A6%E6%91%98/"},{"title":"《MySQL必知必会》书摘","text":"前面的章节介绍的SQL,MySQL等内容,就不记笔记了. 查询数据库信息:status查询数据库变量:show status 查找使用like 第六章:过滤数据WHERE 子句操作符范围值检查 SELECT uid,username FROM t_user WHERE uid BETWEEN 3 AND 6; 范围值检查SELECT uid,username FROM t_user WHERE username IS NULL; 返回的是字段为NULL的列(不是等于0),使用IS NOT NULL可以查询非NULL结果 第七章:数据过滤组合WHERE 子句AND ORAND与OR关键字,功能不言而喻,但是在组合使用时AND的优先度高于OR,正确的使用需要使用圆括号明确的分组相应的操作. INSELECT uid,username FROM t_user WHERE uid IN(4,5); 为什么要使用IN操作符? IN操作符的语法更清楚且直观. 在使用IN时,计算的次序更容易管理(因为使用的操作符更少) IN操作符一般比OR操作符执行更快. IN的最大优点是可以包含其他SELECT语句,使得能够更动态的建立WHERE子句. NOTNOT操作符有且只有一个功能,就是否定它之后的任何条件.SELECT uid,username FROM t_user WHERE uid NOT IN(2,5); 第八章:用通配符进行过滤LIKE操作符 使用%可以进行通配搜索,例如: %l, a%b,b%. 注意:%不仅匹配一个或多个,还可以匹配0个字符.另外%不可以匹配NULL,是一个例外. 使用_可以匹配一个字符,但是不能多也不能少. 第九章:用正则表达式进行搜索select uid,username from t_user where username REGEXP'ab'; 注意:MYSQL仅支持正则表达式的一个很小的子集. LIKE 和 REGEXP的区别 LIKE匹配整个行,如果被匹配的文本在列值中出现,LIKE将不会找到它,相应的行也不会返回(除非使用了通配符).而REGEXP在列值内进行匹配,如果被匹配的文本在列值中出现,REGEXP将会找到它,对应的列将会被返回.这是一个非常重要的区别.SELECT uid,username FROM t_user WHERE username REGEXP`1000|2000`; 匹配两个字符串其中的一个. 匹配几个字符之一SELECT uid,username FROM t_user WHERE username REGEXP`[123]Tom`; 匹配范围,例如1到5REGEXP`[1-5]Tom` 剩下的内容基本参考正则的语法,就不记笔记了,但是注意SQL中的预定义字符集不同与java中,请自行查找. 匹配字符的出现次数同正则语法中. 第十章:创建计算字段拼接字段 在MySQL中使用Concat()函数拼接两个列 SELECT Concat(username,uid) FROM t_user; 第十一章:使用数据处理函数 SELECT uid, UPPER(username) AS username_upcase FROM t_user; 常用的文本处理函数 Left() 返回左侧的字符 Length() 返回字符串的长度 Locate() 找出字符串的一个子串 Lower() 将串转小写 LTrim() 去掉串左边的空格 RTrim() 去掉右边的字符 Soundex() 去掉串的SOUNDEX值 SOUNDEX是一个将任何字符串转换为描述其语音表示的字母数字模式的算法.考虑了类似的发音字符和音节,能够对字符串进行发音对比而不是字符的对比.该算法不是SQL的概念,但是大多数DBMS都支持. 应用场景:查寻发音类似的字符 SubString() 返回子串的字符 Upper() 将串转换为大写 第十二章:汇总数据聚合函数(aggregate function)运行在行组上,计算和返回单个值的函数. AVG() 平均值 COUNT() 行数 Tips:COUNT(*)会包含值,但是指定列名的会忽略. MAX() 最大值 会自动忽略NULl值的行 MIN() 最小值 会自动忽略NULl值的行 SUM() 列值之和 会自动忽略NULl值的行 第十五章:联结表1234SELECT vend_name,prod_name,prod_price FROM vendors,products WHERE vendors.vend_id = products.vend_id ORDER BY vend_name,prod_name; 上式使用的是等值联结,这种联结也被称为内部联结. 在使用联结时一定不要忘记WHERE子句,否则返回的笛卡尔积比你想象的数据多的多.同时请注意,不正确的过滤条件导致MySQL返回不正确的值. 123SELECT vend_name,prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id= products.vend_id 语句中的SELECT与前面相同,但是两个表之间的关系是FROM子句的组成部分,以INNER JOIN指定.在使用这种语法时,联结条件用特定的ON子句而不是WHERE子句给出.传递给ON的实际条件与传递给WHERE的相同.ANSI SQL标准推荐INNER JOIN语法. 第十七章:组合查询使用UNION 使用时只需要将在给出的每条的语句中加上UNION 例:查找价格小于5的所有商品,还包括供应商为1001和1002的所有商品(不考虑价格) 1234567SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price &lt;= 5 UNION SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN(1001,1002) 使用UNION的注意事项 UNION必须由两条或两条以上的SELECT语句组成使用,语句中间使用UNION分割 UNION中的每个查询必须包含相同的列,表达式或聚合函数 列数据类型必须兼容,不必完全相同,但是必须是DBMS可以隐式转换的类型 如果从多表中查询到了相同的数据,默认是去除重复的,如果需要所有项目使用UNION ALL 使用UNION时ORDER BY子句只能有一次出现,并且作用整个结果 第十八章:全文本搜索 PASS第十九章:插入数据 尽量避免全字段插入,因为这样的SQL语句高度依赖表中列的定义次序,是很不安全的. 插入多行每组值用一对圆括号括起来,用逗号分割. 插入检索出的数据 INSERT SELECT123456789101112INSERT INTO customers( cus_id, cus_email, cus_name, cus_city)SELECT cus_id,cus_email,cus_name,cus_cityFROM custnew; 注意:虽然上例使用了相同的列名,但其实不要求匹配,甚至MySQL是不关心SELECT返回的列名,它使用的是列的位置.FROM中可以使用WHERE. 第二十章:更新和删除数据更新数据 UPDATEUPDATE customers SET cust_email=&quot;email@gmail.com&quot; WHERE cust_id=1999; 注意:如果不是想要更新全表,一定不要忘记WHERE IGNORE关键字:如果UPDATE语句更新多行,并且在更新这些行的其中一部分发生错误,则整个UPDATE操作都会取消,回滚值.为了即使发生错误也进行更新可以使用IGNORE关键字 删除数据 DELETE DELETE不需要列明或者通配符,DELETE删除整行而不是列,删除指定列使用UPDATE DELETE删除行,但是不删除表本身 如果需要更快的删除,使用TRUNCATE TABLE,它完成相同的工作,但是速度更快(因为TRUNCATE是删除原有的表,并且重新创建一个表,而DELETE是逐行删除) 第二十一章:创建和操作表 创建表时,表名必须不存在,否则报错.如有需要先删除后创建.如果需要在一个表不存在的时候创建使用关键字IF NOT EXISTS,这样只有在表名不存在的时候才会创建. 使用主键PRIMARY KEY(vend_id),多主键:PRIMARY KEY(order_num,order_item) AUTO_INCREMENT 使用自增的缺点是插入时都不知道生产的值是谁,可以使用 SELECT last_insert_id();,该语句将返回最后一个AUTO_INCREMENT值 设置表字段的默认值:quantity int NOT NULL DEFAULT 1,MySQL数据库引擎类型 在创建表是可以在最后使用ENGINE=InnoDB指定引擎,MySQL中具有多个引擎,具有不同的特点和特性 常见引擎 InooDB:一个可靠的事物处理引擎,不支持全文搜索 MEMORY:功能同MYyISAM,但是数据存储在内存中,速度很快(适合添加临时表) MyISAM:是一个性能极高的引擎,它支持全文本的搜索,但是不支持事物处理. 注意:外键不能跨引擎使用,即使用一个引擎的表不能引用具有不同引擎表的外键 更新表 ALTER TABLE 增加列:ALTER TABLE vendors ADD vend_phone CHAR(20); 删除列:ALTER TABLE vendors DROP COLUMN vend_phone; 增加外键:ALTER TABLE products ADD CONSTRAINT fk_products_vendors FOREIGN KEY (vend_id) REFERENCES vendors(vend_id) 重命名表:RENAME TABLE customers2 TO customers;第二十二章:视图 我的了解:一个暂时存储数据的虚拟表,时我们可以重启SQL语句,简化操作,保护表中的隐私数据,更改时间格式和表示,视图可以返回与底层表不同格式的数据. 视图的规则和限制 视图必须唯一命名,且不能和其他表或视图重名,数量不限 视图的创建需要足够的访问权限 视图可以嵌套,即可以利用其他视图中检索出的数据构造一个视图 检索视图时可以使用ORDER BY,这样会覆盖视图中的ORDER BY 视图不能索引,也不能有关联的触发器或默认值 视图可以和表一起使用,例如联结视图和表进行SELECT 创建视图 使用CREATE VIEW语句创建 使用SHOW CREATE VIEW viewname;来查看创建视图的语句 使用DROP VIEW viewname删除视图 12345CREATE VIEW productocustomers ASSELECT cust_name,cust_contact,prod_id FROM customers,orders,orderitems WHERE customers.cust_id = orders.cust_id AND orderitems.order_num = orders.order_num; 视图的其他用途,自行了解 利用视图简化复杂的联结 使用视图重新格式化检索出的数据,加文本处理函数等 用视图过滤不需要的数据 使用视图与计算字段 第二十三章:存储过程 很多时候需要使用复杂的多条语句才能完成一次操作,这时可以创建存储过程,为之后的使用而保存的一条或多条的MySQL语句.可以看做批文件,但是作用不局限与批处理. 为什么要使用存储过程 优点: 简化对变动的管理,如果表名或列名有变化,只需要更改存储过程的代码,使用的人甚至不需要这些变化. 提高性能,因为使用存储过程比单独使用SQL语句快 存在一些只能用在单个请求的MySQL元素和特性,存储过程可以使用它们编写功能更强更灵活的代码(下一章) 简而言之:简单,安全,高性能 缺点: 编写存储过程更复杂,需要更高的技能 没有较高的权限不可以创建存储过程 创建存储过程12345CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END; 存储过程定义时可以在其中接受参数,在()中定义. 注意:如果在命令行中编写存储过程是结束符会使存储过程被错误解析,发生报错.解决办法:修改命令行中的语法分隔符.(自行百度) 使用存储过程CALL productpricing() 编写带变量复杂的存储过程:PASS第二十四章:游标 好像是在存储过程中创建 创建游标123456CREATE PROCEDURE processorders()BEGIN DECLARE ordernumbers CURSOR FOR SELECT ordernum FROM orders;END; 使用游标: 打开游标:OPEN CURSOR,关闭游标:CLOSE ordernumbers; 使用FETCH语句访问游标的每一行,FETCH指定检索什么数据,检索出的数据存储在什么地方.它还向前移动游标中的内部行指针,使下一条FETCH语句检索下一行(不能重复读取同一行),编写在存储过程中 编写过程:pass 第二十五章:触发器 如果需要在某些事件发生时自动执行怎么办,例如:售出商品自动减库存,删除行时保留副本 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句:DELETE INSERT UPDATE,其他语句不支持触发器 创建触发器 创建触发器需要4个条件 唯一的触发器名 触发器关联的表 触发器响应的操作(DELETE,INSERT,UPDATE) 触发器何时执行(处理前或处理后) 1CREATE TRIGGER newproduct AFTER INSERT ON products FROM EACH ROW SELECT 'Product added`; ps:我自己编写的一直报错,不知道是什么问题,有可能是版本的问题吗. 删除触发器: DROP TRIGGER newproduct;后面还有视图组合触发器等待:pass第二十六章:事务处理注意使用支持事物管理的引擎 概念同java中,保证一组操作不会中途停止,它们或整体执行,或完全不执行,如果发生错误则回退到某个已知的安全的状态 术语 事物(transaction) 指一组SQL语句 回退(rollback) 指撤销指定SQL语句的过程 提交(commit) 指将未存储的SQL语句结果写入数据库表 保留点(savepoint) 指事物处理中设置的临时占位符(place-holder),你可以对它发布回退(与回退整个事物处理不同) 控制事务处理123456SELECT * FROM ordertotals;START TRANSACTION;DELETE FROM ordertotals;SELECT * FROM ordertotals;ROLLBACK;SELECT * FROM ordertotals; 开始事务START TRANSACTION 那些语句可以rollback:INSERT,UPDATE,DELETE,不能回退CREATE或DROP 创建保留点:SAVEPOINT delete1 每个保留点具有唯一的名字 使用ROLLBACK TO delete1; 保留点越多越好,可以灵活的进行回退 可以修改默认的提交行为: SET autocommit=0第二十七章:全球化和本地化:设置编码校对等 PASS第二十八章:访问控制 控制用户的权限,保证安全.一般不使用root账户,同Linux一样 管理用户,用户存储在mysql表中:USER mysql; SELECT user FROM user; 创建用户,修改权限,删除用户,具体权限:pass第二十九章:数据库维护 ANALYZE TABLE 表名来检查表键是否正常 CHECK TABLE orders.orderitems; 我不知道这两个语句的不同,检查单表的结果是相同的 如果从一个表中删除了大量的数据,使用OPTIMIZE来回收使用的空间,优化表的性能. 启动mysql命令行的选项 --help 表示帮助 --safe-mode 装载减去某些最佳配置的服务器 --verbose 显示全文本消息(为获取更详细的帮助消息与–help联合使用) --version 显示版本信息然后退出 第三十章:改善性能 mysql是一个多线程多用户的DBMS,可以执行多个任务,如果每一个执行慢,所有的请求都会慢,可以使用SHOW PROCESSLIST显示所有的活动进程,还可以使用KILL结束某个线程(需要管理员登录) 总是有多种方法编写SELECT语句,尝试联结,并,子查询等,找出最佳的方法 使用EXPLAIN语句让MySQL解释它将如何执行一个SELECT语句 一般来说存储过程比一条条的SQL快 使用正确的数据类型 尽量不使用通配符匹配行 导入数据是关闭自动提交,因为可能还需要删除索引 SELECT中有一系列复杂的OR条件,可以使用多条SELECT和UNION语句联结,会极大的改善性能 索引改善数据检索的性能,但损害数据插入,删除和更新的性能. LIKE很慢,使用FULLTEXT代替 结束 2020/1/12 20:57","link":"/2020/06/22/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E4%B9%A6%E6%91%98/"},{"title":"《投资中最简单的事》书摘","text":"关键词: 理财评分: ⭐️⭐️⭐️⭐️ 读完之后想说什么投资类的书感觉大多都有通篇废话的感觉，这本书言之有物已经很不错了。书中提到的价值投资是赚钱的，但不是年年都赚钱，如果年年都赚钱，那么就不赚钱了。一个无门槛的投资方法和思想在踩踏之下或许就一文不值了。 投资中有太多的大道理，不要追涨杀跌，不要买高估值，在正确的行业选择正确的公司在正确的时间买入。知道这些道理很简单，但是想要做到你要克服太多东西，其中最难的就是你自己的内心。 我在豆瓣的评论 还是比较中肯的一本投资书，文风还是比较有趣的，但是因为各个篇章的成文时间跨度较大，不是很能形成一个较为中心的思想，不少的内容也是在前前后后反复的提到，算是一个小缺点吧，不过已经比市面上百分之九十的书要强。里面提到的各种理念大家或多或少在各种地方都听到过，也应验了那一句：我听过太多大道理，却依旧过不好这一生，知易行难，自勉吧。 书摘 第二，定价权是核心竞争力。有核心竞争力的公司有两个标准：一是做的是自己可以不断复制的事情，比如麦当劳和星巴克可以不断地跨区域开新店，在全世界成功复制；二是做的是别人不可能复制的事情，具备独占资源、品牌美誉度、专利、技术、寡头垄断地位、牌照准入限制等特征，最终体现为企业的定价权。 迪士尼能够历经百年屹立不倒，很重要的原因是米老鼠和唐老鸭不会要求涨片酬。 投资者必须明白一个道理，市场中没有人能够卖在最高点、买在最低点。 A股既不缺价值，也不缺发现价值的眼睛，缺的是坚守价值的心。其实大家都知道哪些股票被低估，但大家就是都不买，都在等着做右侧投资。 A股市场曾有很长一段时间在“击鼓传花”，反正只要鼓声没有停，你就只管这个涨停买进来下个抛出去，不用关心这只股票是不是好股票，这个公司是不是好公司，有没有好的产品、有没有好的市场定位、有没有好的品牌、有没有好的渠道、有没有好的管理层、有没有低的生产成本——这些都不重要。 市场情绪周期 恐惧是怎样炼成的：1.担忧；2.抵赖；3.害怕；4.绝望；5.恐慌；6.放弃；7.麻木；8.沮丧。 击鼓传花 为什么人们愿买长期收益并不高的垃圾股？这是几种人性的弱点交叉作用的结果。过度自信：自信能在风向改变、垃圾落地之前挣到快钱，自信不会是最后一棒；标题效应：榜样的力量是无穷的，曾听说过某垃圾股如何在短时间内翻几番；过度外推：已经三个涨停了，再来一个板好像也顺理成章。 同一件事，看多者和看空者往往作截然不同的解释——你看到的是你想看到的。 持同一种观点的人，其依据和逻辑往往是截然不同的——你证明的是你想证明的。 同一消息，在不同的市场环境下常有不同的解读——你听到的是你想听到的。 同一事情两种解读，往往是考虑的时间跨度不同。 趋势投资者喜欢追着狗（价格）跑；价值投资者喜欢跟着人（价值）走，耐心等狗跑累了回到主人身边。有时候，狗跑离主人的距离之远、时间之长会超出你能忍受的范围，让你怀疑绳索是否断了。其实，绳索只是有时比你想象的长，但从来不会断。 我们称颂华佗、扁鹊无人能学的医术（个例），西医强调的是双盲法的临床实验（规律）。我们期盼断案如神的包青天（个例），西方依靠的是强调证据和程序的法制（规律）。我们喜欢把人拔高为神（个例），希腊的神却像人一样也会嫉妒、偷情和吵架（规律）。西方文化重规律，中国文化重个例。中国的股市之所以赌性特强，原因之一就是尽管投机炒作平均而言是个多数人亏钱的游戏（规律），但是少数一夜暴富的故事（个例）还是吸引着许多心存侥幸的投机客前赴后继地屡败屡战。 成长股中有大牛股是个例，价值股平均跑赢成长股是规律。不被精彩绝伦的牛股倾倒，不被纷繁复杂的个例迷惑，不抱侥幸心理，不赌小概率事件，坚持按规律投资，这是投资纪律的一种体现，也是投资成功的必要条件。 如果把我过去十几年的投资分析方法做一个简单的概括，最根本的就是要回答三个问题：为什么认为一家公司便宜，为什么认为一家公司好，以及为什么要现在买。这三个问题中，第一个是估值的问题，第二个是公司品质的问题，第三个是买卖时机的问题。 正如乔尔·格林布拉特（Joel Greenblatt）所说，第一，价值投资是有效的；第二，价值投资不是每年都有效；第二点是第一点的保证。正因为价值投资不是每年都有效，所以它是长期有效的。如果它每年都有效，未来就不可能继续有效。 我认为彼得·林奇说得对，他说当有人告诉你“A公司是下一个B公司”的时候，第一要把A卖掉，第二要把B也卖掉。因为第一，A永远不会成为B；第二，B已经被当作成功的代名词，说明它的优点可能已经体现在现在的股价中了。 我认为中国2 500家上市公司中，伟大的公司肯定只占了个位数。A股2 500家公司中有2 000家是垃圾公司，剩下的500家中可能有400家是普通公司，100家可以算是优秀公司，而在这100家中大概有10家是伟大公司。在这种情况下，你觉得自己有能力把这10个左右的伟大公司找出来么？如果可以找出来，你就可以不重视估值。在绝大多数公司只是普通公司的前提下，你必须强调估值。 公司当然是骑师更重要，大公司就是机制和文化更重要。所以，是选骑师、选马还是选赛道，要看公司处于哪个发展阶段。 当然这个不包括一些“中字头”的央企，它们的垄断是国家给的。国家授予的垄断意味着它的定价权受到政策限制。我们并不喜欢垄断本身，我们喜欢的是垄断带来的定价权，所以定价权受限制的垄断没有意义。 政府扶持 政府今天扶持这个明天打压那个，但有些行业越打压越赚钱，有些行业越扶持越亏钱。不是因为政府的力度不够，而是因为有些经济规律是不以人的意志为转移的。扶持其实是鼓励更多的人进入行业而加剧了竞争，打压却限制了新增供给，反而改善了竞争格局并且让行业龙头做大。 历史上的股市见底信号1.市场估值在历史低位；2.M1见底回升；3.降存准或降息；4.成交量极度萎缩；5.社保汇金入市；6.大股东和高管增持；7.机构大幅超配非周期类股票；8.强周期股在跌时抗跌，涨时领涨；9.机构仓位在历史低点；10.新股停发或降印花税。 未出的牌能否构成赢张，事前是可以估算概率的，然而懂得估算的人少之又少。人性的弱点对未出的牌往往抱有过于美好的想象，驱使人们去赌未来的小概率事件。 只要能够避开价值陷阱，投资可以很轻松：找到便宜的好公司，买入并持有，直到股价不再便宜、或者发现公司品质没你想象的好时，卖出。这是一个蠢办法，但正如《美国士兵守则》所说，若一个蠢办法有效，那它就不蠢。 成长的持续性 管子说：“不为不可成，不求不可得，不处不可久，不行不可复。”投资者总是过于关注成长的暴发性而忽视成长的可持续性。其实暴发性成长本质上具有不可预知性和不可重复性，就像彩票一样，总有人中，但一定不是你。投资，宁要有门槛的低增长，不要没门槛的高增长，因为前者可持续，而后者难维系。 很多人做股票也是一样的，涨了，爽了，就满仓；跌了，痛了，就清仓。低点低仓位、高点高仓位就是这么来的。其实，对于逆向投资者来说，最痛的时候，往往是最不该放手的时候。正如索罗斯所说，如果你承受不了失败的痛苦，就不要入市，因为没有人能够百战百胜。 要回答这个问题，我们先回顾一下卖股票的三个理由：基本面恶化；价格达到目标价；有更好的其他投资。换句话说，价值投资买的就是便宜的好公司，所以卖出的原因就是：公司没有想象的好；不再便宜；还有其他更好更便宜的公司。这三个理由均与是否亏损无关。 在别人恐惧时贪婪，在别人贪婪时恐惧。 1.这话很有道理。2.这话说了等于没说。3.很有道理的话一般说了等于没说。4.说了等于没说的话一般很有道理。5.如果你知道别人什么时候恐惧和贪婪，这话很有道理。6.如果你不知道别人什么时候恐惧和贪婪，这话说了等于没说。7.恐惧和贪婪在市场中的直接体现就是估值。恐惧时，估值水平低；贪婪时，估值水平高。8.所以，在估值低时贪婪，在估值高时恐惧。 许多人认为买股票就是买未来，邱国鹭却特别强调现在：“我始终信奉加尔布雷斯（Galbraith）说过的一句话：以为自己能够预测未来的人只有两种，一种是无知的，另一种是不知道自己是无知的。 临渊羡鱼不如退而结网，投资必须把握你能把握的东西，所以对多数人而言，也许更应该买入那些相对于目前的资产、现金流、盈利能力被严重低估的股票。知道自己的能力边界，发挥自己的优势，买便宜的好公司，注意安全边际，注重定价权，人弃我取，在胜负已分的行业里找赢家，这些貌似投资中最简单的事，其实也是投资中最本质的东西。","link":"/2021/05/16/%E3%80%8A%E6%8A%95%E8%B5%84%E4%B8%AD%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E3%80%8B%E4%B9%A6%E6%91%98/"},{"title":"《比特币：一个虚幻而真实的金融世界》书摘","text":"为什么读上高中就听说比特币了，当时几千块吧，当时各种人都认为这就是一种新形的诈骗，确实当时各种IPO骗钱，很多人血本无归，没有多久就矿难了，之后比特币在起起浮浮中一路高涨。 最近我突然意识到，现在和以前已经大为不同，以前可能币价腰斩挖矿就不够电费了，可是在今天这个时间比特币已经超过五万美元了，除非下跌百分之九十五以上才有可能让大家停止挖矿（显卡是拿去挖以太坊了，不过也是一样的，需要跌百分之九十以上才会亏本），悲观的预计可能永远都不会有矿难了，所以比特币非常有可能是会伴随我这一生的存在，转念一想，还能有什么东西是可以保证不死不灭的了，公司吗，人民币吗，美元吗，我想没人可以打包票，而比特币却可以轻易做到，这样一个相伴一生的东西难道不值得去了解它吗。 评分: ⭐️⭐️⭐️⭐️ 阅读时间: 2021/04/20 → 2021/04/26 豆瓣链接: https://book.douban.com/subject/25781918/ 读完之后想说什么前言写的不错，各种概念介绍的不错，就是后半段比较废话，各种话重复来回的说，不过还是值得一读的，就不建议重复读了。 比特币的市场和股市很像，但是又有着诸多的不同， 我在豆瓣的评论 很不错的一本比特币科普书，解答了我心中很多的疑惑，比如为什么比特币不计算一些有意义的事情，比特币未来的前景，比特币会不会被山寨币取代等等。 全书的前半段比较不错，后面部分，尤其是最后两章有凑字数的嫌疑，各种术语翻来覆去的讲，建议只看前半部分。 书摘 1976年，已经77岁的哈耶克完成了《货币非国家化》一书。该书序言的开头是亚当·斯密在《国富论》里面的一段话：“我相信，世界各国的君主，都是贪婪不公的。他们欺骗臣民，把货币最初所含金属的真实成分，次第削减。”该书的中心思想就是，除非各国政府不再拥有对货币创造的垄断权力，否则永远无法实现价格稳定。哈耶克的理想是：在一个国家，发行具有明显差异的，并由不同货币单位构成的货币，包括让私人货币流通，并实现不同货币之间的竞争。只有这样，所有的货币发行单位才会紧缩其货币发行量，以避免因货币不断贬值而最终被淘汰的命运。为此，哈耶克提出了详尽的货币非国家化的方案。 比特币是财富创造和交换的创新。比特币的每笔交易既透明又匿名，每一个拥有网络客户端的人都可以查到全世界所有即时产生的比特币交易，却无须也无法得知这笔交易来自哪里，去向哪里，用作什么用途。比特币第一次从技术上提供了每一个个体自己创造的私有财产处于不可侵犯、不可冻结和不可追踪的状态。比特币的拥有者可以在完全以信任为基础的自由体系中，拥有和享用货币财富。或者说，比特币创造的是一个自己对自己负责、依靠信用运转的世界。货币主权要回归给个人，每个人有选择货币的权力，成为货币财富的主人。 第一，比特币更能实现货币作为交换媒介的功能，具有超越时空和超越主权的优势，应用版图遍布世界。 第二，比特币具有高度流动性的资产的功能，并成为当前全球升值最快的资产。 第三，比特币突破了传统资产负债表只能反映一个企业在某一特定时期全部资产、负债和所有者权益情况的局限，而比特币的账本不仅包括全部历史记录，而且是动态的，可以称得上是全息图像账本。 第一，赋予比特币本身原本没有的意义。例如，比特币可能替代主权货币，甚至成为一种世界货币。比特币没有替代国家货币的使命，比特币的开源本质决定了它不会成为未来世界的唯一货币。 第二，将比特币的地位绝对化、神化，似乎不可替代。比特币的理念表明其一贯支持货币多元化，货币之间要竞争。近来，在比特币挖矿难度大幅提高的背景下，出现了类似比特币原理的若干新数字货币，如莱特币等，虽然各有不同的后发优势，依然无法形成挑战比特币、与比特币平等竞争的局势。比特币最值得肯定的是其开源本性、开放性和没有排他性。在理论上，不排除有一天会产生比比特币更完美的货币。 比特币的创新在很多程序员看来，是那么显而易见，简直就是数学接管世界的起点；而在有些人眼里，这只是毫无价值的浪费电力的传销产物。 中国人民银行南京分行的洪蜀宁应该算是我国体制内最早公开研究比特币的人，早在2011年10月，他就在《中国信用卡》杂志上发表了题为《比特币：一种新型货币对金融体系的挑战》的文章，并对政府提出了3点建议： 1.政府和中央银行应正视比特币的存在，主动出击，动用国家巨大的计算能力，抑制私人挖掘的动力，将绝大多数比特币集中在国家手中。2.研究成立比特币银行，在比特币交易中推行中间机构，以消除其匿名性，使其可以被监管。 3.国际联合发行比特币本位的信用货币，从而促进非主权货币体系的建立。通过这种新型的国际结算货币来挑战美元的霸权地位，使国际金融体系更加和谐、稳定。 注释：最近国内官方的态度也在转变，感觉很快就会有大变化。 金属货币的世界靠天然的产量限制货币发行量，靠天然的化学属性进行防伪，靠天然的珍稀性保证购买力。 纸币的世界靠中央银行的领导和经济专家决定发行多少货币，靠不断提高制作工艺和更高级的验钞机进行货币防伪，靠国家力量来保证购买力。 而在比特币的世界，上面的规则通通失效。数字世界有自己的规则：通过数学，更确切地说是通过密码学保证比特币种种天方夜谭般不可思议的特性 同样，没有任何人有权力操纵他人账号上的比特币。这是在人类历史上，第一次从技术上保障了私人财产的神圣不可侵犯、不可追踪、不可冻结 挖矿的意义并不是白白消耗电力和磨损硬件来做无意义的计算以获得比特币，而是通过大量计算防止作弊，维护整个比特币系统的安全。 不过，片面指责其洗钱和用于其他违法犯罪活动也是不太公平的。一直以来，由于比特币高度的匿名性，人们觉得它可能会成为一个合适的货币替代品来进行毒品交易和洗钱，以及相关的其他非法活动。然而，相同的问题在使用现金时也可能发生。现金也可用于毒品交易、洗钱、逃税等。问题不在于货币的形式，而在于使用者用它做什么。 价值存在于共识（信任）和交易本身。不是为什么值得信任，而是你是否选择信任。 注释：感觉类似与股市，你相信公司可以成长就可以买入，大家都认同这个公司股价自然就会上涨。短期的股市更像是博人心。之前听单立人的播客，里面也提到类似的东西，大家相信单立人，而单立人有什么，只有大家的相信，除此之外没有了。一个东西由信任组成这将是无所不摧的，例如公司 民族 国家 理念，这或许就是人类数千年来的根本。","link":"/2021/04/27/%E3%80%8A%E6%AF%94%E7%89%B9%E5%B8%81%EF%BC%9A%E4%B8%80%E4%B8%AA%E8%99%9A%E5%B9%BB%E8%80%8C%E7%9C%9F%E5%AE%9E%E7%9A%84%E9%87%91%E8%9E%8D%E4%B8%96%E7%95%8C%E3%80%8B%E4%B9%A6%E6%91%98/"},{"title":"《海龟交易法则》书摘","text":"关键词: 理财，交易系统 时间: 2021/03/29 → 2021/04/12评分: ⭐️⭐️⭐️豆瓣链接: https://book.douban.com/subject/24325274/ 为什么读各种地方都有吹的，想看看具体是啥交易法则。 读完之后想说的什么收获不大，讲的是在期货市场的交易，我一个买基金的学到的不多，不过其中的思想还是可以的。 另外作者行文中有一股溢出的骄傲，看的头疼。 豆瓣评论 7分，看的是封面是一只海龟的版本，译者和出版社都是相同的，应该就是这本。我的建议是先看附录的内容，里面介绍了交易法则的具体内容，算是全是的总领，然后再从头看。这本书介绍的是关于如何选择自己的交易系统，如何使用和坚持。 里面都例子都是在买期货，就看个概念，学一点思想，找到属于自己的交易法则才是真。ps:感觉里面有不少话来来回回说。 书摘 书摘 损失厌恶（loss aversion）：对避免损失有一种强烈的偏好。也就是说，不赔钱远比赚钱更重要。 •沉没成本效应（sunk costs effect）：更重视已经花掉的钱，而不是未来可能要花的钱。 •处置效应（disposition effect）：早早兑现利润，却让损失持续下去。 •结果偏好（outcome bias）：只会根据一个决策的结果来判断它的好坏，而不去考虑决策本身的质量。 •近期偏好（recency bias）：更重视近期的数据或经验，忽视早期的数据或经验。 •锚定效应（anchoring）：过于依赖（或锚定）容易获得的信息。 •潮流效应（bandwagon effect）：盲目相信一件事，只因为其他许多人都相信它。 •小数定律（the law of small numbers）：从太少的信息中得出没有依据的结论。 海龟培训课的所有内容可以归结为以下4个要点： 1. 掌握优势：找到一个期望值为正的交易策略，因为长期来看它能创造正的回报。 2. 管理风险：控制风险，守住阵地，否则即使你有一个期望值为正的系统，你也等不到它创造成果的那一天。 3. 坚定不移：唯有坚定不移地执行你的策略，你才能真正获得系统的正期望值。 4. 简单明了：海龟方法的精髓其实很简单——抓住每一个趋势。你的大部分利润可能就来自两三次成功的交易，所以不要错过任何趋势，否则你全年的努力可能都会化为泡影。这很简单，也很容易理解，只是不容易做到。 像海龟一样思考 1. 重要的是现在：不要对过去念念不忘，也不要去预测未来。前者对你无益，后者是徒劳的。 2. 从概率角度考虑问题，不要预测未来：不要试图作出正确的预测，唯有使用概率对你有利的方法，你才能在长期内获得成功。 3. 对你自己的交易结果负责：不要把你的错误和失败归咎于其他人、市场、你的经纪人等。要对自己的错误负责，从错误中学习。 交易是你进行的，你应该对结果负责。不要责怪任何人给了你坏的建议，也不要责怪任何人没有把秘诀告诉你。如果你做了愚蠢的事，要从错误中学习，不要装作没有犯错。然后去想办法避免再犯同样的错误。 喜欢推卸责任的人必败无疑。 大多数交易者都相信支撑和阻力现象的存在，这又进一步加强了支撑力和阻力，因为对这种现象深信不疑的交易者反过来也会促进这种现象。如果有很多交易者相信价格一旦下跌到某个水平就会有大批买入者接盘，那么他们就更容易相信价格跌到这个水平时必然会反弹。这种信念将削弱他们在这个价位卖出的意愿，因为他们更愿意晚些再卖——等价格在这个支撑位反弹后再卖。于是，对支撑和阻力现象的笃信使它成了一种自我实现的机制。 我认为以下几点才是期货交易者的主要败因： •没有计划：许多交易者的行动依据是直觉、传闻、猜测，还有对自身预测能力的自信。 •风险过大：许多在其他方面很出色的交易者是因为承受了过大的风险而破产的。我所说的大风险可不止比谨慎水平大50%或100%。我曾见过某些交易者的风险比我心目中的谨慎水平大5~10倍，即使对激进交易策略来说也是如此。 •不切实际的期望：许多新交易者之所以承受过大的风险，是因为他们对自己的赢利能力和回报水平抱有不切实际的期望。这也是新手们相信自己仅凭那些基础数据就能开始交易的原因。他们相信自己足够聪明，可以在没受过多少培训的情况下仅凭那一点点信息就“击败”市场。 交易者效应：如果一种方法在近期赚了很多钱，那么其他交易者很可能会注意到它，开始用类似的方法模仿它，这很容易导致这种方法的效果不再像一开始那样好。 市场不会在乎你的感受。它既不会在你得意洋洋的时候吹捧你，也不会在你灰心丧气的时候安慰你。所以，交易世界并非适合每个人。如果你不愿意接受市场的现实，不愿意承认自己的缺陷、恐惧和失败，你就不会成功。 成功海龟的交易心得 1. 掌握优势：找到一个期望值为正的交易策略，因为长期来看它能创造正的回报。 2. 管理风险：控制风险，守住阵地，否则即使你有一个期望值为正的系统，你可能也等不到它创造成果的那一天。 3. 坚定不移：唯有坚定不移地执行你的策略，你才能真正获得系统的正期望值。 4. 简单明了：长久来看，简单的系统比复杂的系统更有生命力。 也就是说，人们是不经意间踏上轨道的。一旦上了轨道，离开轨道就需要有意识地努力了。如果不离开，那么他们终将走到轨道的终点，而且可能并不是他们梦想中的终点。由于他们并不是有意踏上轨道的，他们甚至可能意识不到自己的方向，直到猛然发现自己已经远离了梦想。 交易行业里有这么一句话：“有老交易者，也有不怕死的交易者，但是没有不怕死的老交易者。”不用止损点的交易者十有八九会破产。海龟们一定会用止损点。 交易行业里还有一句老话：“落袋为安的人永远也不会破产。”但海龟们不会同意这种论调。趋势跟踪者们最常犯的错误之一就是过早地退出赢利的头寸，也就是过早地“落袋为安”。","link":"/2021/04/15/%E3%80%8A%E6%B5%B7%E9%BE%9F%E4%BA%A4%E6%98%93%E6%B3%95%E5%88%99%E3%80%8B%E4%B9%A6%E6%91%98/"},{"title":"《爱你就像爱生命》书摘","text":"爱你就像爱生命评分: ⭐️⭐️⭐️⭐️豆瓣链接: https://book.douban.com/subject/27111096/阅读时间: 2020/11/30 → 2020/12/14 注：只看到了一半，后半段多为李银河的书信。 代序 爱情十问 标注(黄色) - 位置 77 爱一个人虽然是需要幸运的，即需要与那个“对”的人的偶遇，但是会不会爱、懂不懂爱、能不能爱是一个人能够最终得到爱的关键。如果你根本不知道爱是什么，就不会去爱上一个人；如果没有爱的能力，那就不会遇上爱，找到爱；如果不会去爱，也就不会被爱。即使那个“对”的人出现了，你也不会认出他来，只会与他失之交臂。 致李银河 标注(黄色) - 最初的呼唤 &gt; 位置 133 当我跨过沉沦的一切向着永恒开战的时候你是我的军旗 标注(黄色) - 最初的呼唤 &gt; 位置 155 祝你今天愉快。你明天的愉快留着我明天再祝。 标注(黄色) - 最初的呼唤 &gt; 位置 173 我的灵魂里有很多地方玩世不恭，对人傲慢无礼，但是它有一个核心，这个核心害怕黑暗，柔弱得像绵羊一样。只有顶平等的友爱才能使它得到安慰。你对我是属于这个核心的。 标注(黄色) - 最初的呼唤 &gt; 位置 191 我整天在想，今天快过去吧，日子过得越快，李银河就越快回来了。你不要觉得这话肉麻，真话不肉麻。祝你愉快。 标注(黄色) - 最初的呼唤 &gt; 位置 217 肉麻是什么呢？肉麻就是人们不得不接受降低人格行为时的感觉。有人喜爱肉麻是因为什么呢？是因为他们太爱卑贱，就把肉麻当成了美。肉麻还和现在文学作品中的简单粗糙不同，它挺能吸引人呢。所谓肉麻的最好注脚就是才子佳人派小说，它就是本身不肉麻，也是迎合肉麻心理的。鲁迅是最痛恨肉麻的，我的这个思想也是从他老人家那里批发来的。 标注(黄色) - 最初的呼唤 &gt; 位置 261 有无数为人师表的先生们在按照他们自己的模样塑造别人，真是可惜。 标注(黄色) - 爱你就像爱生命 &gt; 位置 279 还有我。我是爱你的，看见就爱上了。我爱你爱到不自私的地步。就像一个人手里一只鸽子飞走了，他从心里祝福那鸽子的飞翔。你也飞吧。我会难过，也会高兴，到底会怎么样我也不知道。 标注(黄色) - 爱你就像爱生命 &gt; 位置 288 我会不爱你吗？不爱你？不会。爱你就像爱生命。 标注(橙色) - 真正的婚姻全是在天上缔结的 &gt; 位置 308 我和你说，你真是一个再好不过的人，我走遍世界也找不到，你太好了。 标注(橙色) - 真正的婚姻全是在天上缔结的 &gt; 位置 309 你想知道我对你的爱情是什么吗？就是从心底里喜欢你，觉得你的一举一动都很亲切，不高兴你比喜欢我更喜欢别人。你要是喜欢了别人我会哭，但是还是喜欢你。你肯用这样的爱情回报我吗？就是你高兴我也高兴，你难过时我来安慰你，还有别爱别人！可惜的是你觉得我长得难看。这怎么办？我来见你时应当怎样化装？你说吧。 标注(橙色) - 请你不要吃我，我给你唱一支好听的歌 &gt; 位置 340 我把我整个的灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。 标注(橙色) - 孤独的灵魂多么寂寞啊 &gt; 位置 361 我真不想有一天我自己觉得我有了足够的智慧，可以够用了，足够明辨是非了。 标注(黄色) - 假如你愿意，你就恋爱吧 &gt; 位置 479 因为什么都不是爱的对手，除了爱。 标注(黄色) - 美好的时光 &gt; 位置 496 星期三晚上，我和平常一样，在平常的地点平常的时间等你。 标注(黄色) - 人为什么活着 &gt; 位置 519 不管你是谁，是神仙也好，是伟人也好，请你来共享我们的爱情。这不屈辱谁，不屈辱你。 标注(黄色) - 你和我是很不同的人 &gt; 位置 536 我觉得我爱了你了，从此以后，不管什么时候我都不能对你无动于衷。我可不能赞成爱里面一点责任没有。我当然反对它成为一种枷锁，我也不能同意它是一场宴会。我以为它该是终身不能忘却的。比如说，将来你不爱我了，那你就离开我，可是别忘了它。这是不该忘记的东西。 标注(黄色) - 我要你，和我有宿缘的人 &gt; 位置 561 真的，我要好好爱你，好好地。不一定要你爱我，但是我爱你，这是我的命运。 标注(黄色) - 没有你的生活 &gt; 位置 566 你可要我告诉你我过的是什么生活？可以告诉你，过的是没有你的生活。 标注(橙色) - 我厌恶模式化的生活 &gt; 位置 629 我知道你说的是要从那个可怕的、已经模式化的生活泥坑里爬出来，在那里人们的生殖细胞给他们造成无穷的灾难。本来年轻人生就的飞毛腿是可以从上面跑过去的，不幸那些细胞给他们坠上几块大石头。 标注(橙色) - 我厌恶模式化的生活 &gt; 位置 637 对了，要说模式化的生活，我可真腻味它。见也见烦了，且不说它的苦处。中国人说苦处也就是乐处，这就可以说明有人为什么爱吃臭豆腐：他们都能从臭里体验出香来。这可以说明懒于改造世界的人多么勤于改造自己。我发誓：在改造自己以适应于社会之前非先明辨是非不可，虽然我不以为自己有资格可以为别人明辨是非。 标注(橙色) - 我厌恶模式化的生活 &gt; 位置 642 人们懒于改造世界必然勤于改造自己，懒于改造生产方式，对了，懒于进行思想劳动必然勤于体力劳动，懒于创造性的思想活动必然勤于死记硬背，比方说，吃臭豆腐、大寨、大庆的齐莉莉。中国人对它们以及她诸多赞美正是香臭不知。比方说你我，绝不该为了中国人改造自己，否则太糊涂。比方说中国孩子太多，生孩子极吃苦头，但是人们为什么非生不可呢？我猜是因为：一、大家都生，二、怕老了，三、现在不生以后生不了。 标注(橙色) - 我厌恶模式化的生活 &gt; 位置 650 男孩子只能爱女孩子，可这不是因为——该死，生殖细胞，而是因为她可爱，有很多非爱不可的地方。 标注(橙色) - 我好像害了牙痛 &gt; 位置 668 闭起嘴被人当成傻瓜胜于张开嘴消除一切疑虑。 标注(橙色) - 夏天好吗 &gt; 位置 684 麦子熟了，天天都很热。等到明天一早，我就去收割。我的爱情也成熟了，很热的是我的心，但愿你，亲爱的，就是收割的人！ 标注(橙色) - 哑巴爱 &gt; 位置 713 你不在我多难过，好像旗杆上吊死的一只猫。猫在爱的时候怪叫，讨厌死啦！可是猫不管情人在哪儿都能找到她。但是如果被吊死在旗杆上它就不能","link":"/2020/12/16/%E3%80%8A%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD%E3%80%8B%E4%B9%A6%E6%91%98/"},{"title":"《这样做迈出投资第一步》书摘","text":"关键词: 理财，书摘 短评：个人目前读过最好的理财书。 封面: https://img1.doubanio.com/view/subject/s/public/s30022307.jpg状态: 完成评分: ⭐️⭐️⭐️⭐️⭐️豆瓣链接: https://book.douban.com/subject/30485415/阅读时间: 2020/12/21 → 2020/12/25 书摘 今天有人对持有现金等价物感到很欣慰，他们不该如此；他们选择了一种可怕的长期资产，这种资产实际上不会有任何回报，而且肯定会贬值。——沃伦·巴菲特（Warren Buffett） 通胀是一种税，其破坏性远大于任何税种。——沃伦·巴菲特 一般的投资者应该找个出色的交易商代他交易，然后自己去做些真正喜欢的事情。——《巴菲特与索罗斯的投资习惯》 据说小道消息往往是让毕生积蓄打水漂最快捷的方式。 七二法则”——本金翻倍的秘密为了更直观地理解复利，财务上的“七二法则”用以方便计算复利的效果。所谓“七二法则”，就是一笔投资通过复利，增值1倍所需的时间为72除以该投资年化收益率所得的商。举个例子，假设投资100万元想要变成200万元，在年化收益率为10%的情况下，大概需要7.2年，即72除以10；而年化收益率为5%的情况下，大概需要14.4年。从数学上来看，增值1倍的实际数值需要更准确地计算，牵涉比较复杂的公式，69.3其实是更接近正确结果的值。之所以选用72，是因为它有较多因数，容易被整除，更方便计算。对于一般增长率，由5%至10%来说精准度还是够的；但对于较高的收益率，准确度会降低。对于低收益率或复利频率较高的情况，69.3会提供较准确的结果。 正如中国银行保险监督管理委员会主席曾表示的：“理财产品收益率超过6%就要打问号，超过8%就很危险，达到10%以上就要准备损失全部本金。” 如一句谚语中所蕴藏的哲理：“我只想知道我将来会死在什么地方，这样我就永远不去那儿了。” 其一，抛开细枝末节，这位美国女孩所说的其实是一种“财”“貌”交易。但致命的是，美貌会逐年递减，而金钱却不会平白无故地减少，相反，可能还会逐年递增。其二，对于一件会加速贬值的物品，明智的选择是租赁，而非购入。因而，有钱人只会和这位美女交往，却不会和她结婚。其三，相对于碰到一个有钱的傻瓜，想办法把自己变成年薪50万的人胜算更大。 在这里，我们给大家提供一个通过业绩挑选债基的“四四三三法则”：第一个“四”代表选择两年、三年以来业绩表现排名在同类型产品前1/4的基金；第二个“四”代表选择近一年来业绩表现排名在同类型产品前1/4的基金；而第一个“三”代表选择近6个月业绩表现排名在同类型产品前1/3的基金；第二个“三”代表选择近3个月业绩表现排名在同类型产品前1/3的基金。简单地说，“四四三三法则”背后的核心，其实还是关注基金的长期“持久力”而非短期“爆发力”。 “靠水晶球谋生的人，注定要吃碎在地上的玻璃。” 这一困境在于，短期的择时更像是一种博弈华尔街教父本杰明·格雷厄姆曾经说过一句话：“市场短期是一台投票机，但长期是一台称重机。”其意思是，股市的短期表现，实际上是市场参与者买卖价格的结果，就好像在一群人的投票下，产生了“涨”“跌”的表现。有“利多”或“利空”，市场应声而上或应声而下，都体现了这种“投票”结果。对于短期交易的人来说，重点不在于研究价值的多少，重点在于研究人们的情绪会导致怎样的投票结果，并利用此来获利。而称重机则是指股票价格从长期看，还是会遵从价值的原则，价值就是股票的重量。股价短期可以过分高或低，但从长远看，不会离其价值太远，它有多少价值，就有多少重量，即市场价格趋向于其价值。从这个角度出发，股市的参与者也大致可以分为两种人：第一种人交易的是“自己的心”，可被称为价值投资者；第二种人交易的是“别人的心”，在此被称作趋势投资者。价值投资者眼里，股票的价格取决于公司的质地，公司值多少钱，自己心里有标准，在实际交易时就围绕着这个标准高抛低吸。而在趋势投资者眼里，股票更像是用来交易的筹码，股价的变动取决于对手的想法和市场的供求，跟随趋势是核心交易原则，所以追涨杀跌，依靠止损来控制风险。他们将投资的得失寄托在“别人的心”上，其中难度可想而知。 大部分投资者一生都沉迷于“猜顶和探底”的游戏，但事实证明：这是一个不可能完成的任务。没人能真正预测大市或个股的“底和顶”，这也就是为什么大部分投资者终其一生都没有跨越财富自由的门槛。——沃伦·巴菲特 “行情在绝望中诞生，在半信半疑中成长，在憧憬中成熟，在希望中毁灭”，这是史上最成功的基金经理——约翰·邓普顿的一句名言，他所说的这个循环在许多国家的股市中都多次上演。 投资者情绪转变之迅速达到令人难以置信的程度，甚至即使事实根本没有任何改变。投资者不断地在3种情绪之间变化：担心害怕、扬扬得意、灰心丧气。投资的窍门不是要学会相信自己内心的感觉，而是要约束自己不去理会内心的感觉。只要公司的基本面没有根本的变化，你就应该一直持有你手中的标的。——彼得·林奇 “对市场要保持敬畏之心”，市场“是怎样”和“会怎样”，永远比“应该怎样”重要。 马克·塞勒尔所说的能成就伟大投资者的“护城河”包括7种特质：在他人恐慌时果断买入股票，而在他人盲目乐观时卖掉股票的能力；极度着迷于投资这个游戏，并有着极强的获胜欲；从过去所犯错误中吸取教训的强烈意愿；基于常识的与生俱来的风险嗅觉；对自己的想法怀有绝对的信心，即使在面对批评的时候；左右脑都擅长运用；即使大起大落，丝毫不改变投资思路的能力，这是最重要同时最少见的特质。 首先，学会忘记自己的投资成本。通常来说，是否卖出手中资产的衡量标准，不应该是自己已经赚了多少钱，而应该是资产目前的价格是否合理、未来是否还有上涨空间，而这些都与投资者本身的买入成本无关，即市场并不会因为你账面盈利高就不再上涨，也不会因为你被深度套牢就出现反弹，资产价格的未来走势与基本面、市场供需等客观因素有关。所以，投资者只有忘掉自己的投资成本，客观冷静地去分析市场，才能实现最大的回报。 在很多人心中，基金经理是非常神秘的存在：掌管着几十亿的资金，在股市的“血雨腥风中勇猛杀敌”，一边两眼不离四连屏上的K线图和MACD柱（指数平滑异同移动平均线），一边唰唰地向交易员下达指令，每个动作都干净利落，看起来胸有成竹。“我的基金经理一定无所不能”，很多基民应该都曾有过这样的想法。甚至有些人认为基金经理可以准确预测市场的涨跌，比如经常有朋友会私信给笔者：“贵司的基金经理怎么看明天的走势？是涨还是跌？”","link":"/2021/01/03/%E3%80%8A%E8%BF%99%E6%A0%B7%E5%81%9A%E8%BF%88%E5%87%BA%E6%8A%95%E8%B5%84%E7%AC%AC%E4%B8%80%E6%AD%A5%E3%80%8B%E4%B9%A6%E6%91%98/"},{"title":"《黄金时代》书摘","text":"关键词: 王小波 封面: https://img9.doubanio.com/view/subject/s/public/s29419096.jpg状态: 完成评分: ⭐️⭐️⭐️⭐️豆瓣链接: https://book.douban.com/subject/27013741/阅读时间: 2020/12/29 → 2020/12/31 书摘，来自kindle导出 黄金时代标注(黄色) - 位置 88 那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受槌的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了槌的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也槌不了我。 标注(黄色) - 位置 450 忽然间我心里一动，在她红彤彤的身体上俯身下去。我都忘了自己干了些什么了。我把这事说了出来，以为陈清扬一定不记得。可是她说，“记得记得！那会儿我醒了。你在我肚脐上亲了一下吧？好危险，差一点爱上你。” 标注(黄色) - 位置 494 陈清扬说，那一回她躺在冷雨里，忽然觉得每一个毛孔都进了冷雨。她感到悲从中来，不可断绝。忽然间一股巨大的快感劈进来。冷雾，雨水，都沁进了她的身体。那时节她很想死去。 三十而立标注(黄色) - 位置 976 小转铃说过，她需要我这个朋友，她要和我形影不离，为此她不惜给我当老婆。和一个朋友在一起过一辈子可够累的。所以我这么和她说：也许咱们缘分不够，也许你能碰上一个人，不是不惜给他当老婆，而是原本就是他老婆。 标注(黄色) - 位置 1035 “别怕，往前走，打断我骨头的劲儿上哪儿去了？别看地，地上没钱，有钱我比你先看见。抬头！挺胸！” 标注(黄色) - 位置 1487 我早就超越了老鼠，所以我也不向往仓房，如果我要死，我就选择一种血淋淋的光荣。我希望他们把我五花大绑，拴在铁战车上游街示众。当他们把我拖上断头台时，那些我选中的刽子手——面目娟秀的女孩，身穿紧绷绷的黑皮衣裙，就一齐向我拥来，献上花环和香吻。她们仔仔细细地把我捆在断头桩上，绕着台子走来走去，用钢刀棍儿把皮带上挂的牛耳尖刀一把把钢得飞快，只等炮声一响，她们走上前来，随着媚眼送上尖刀，我就在万众欢呼声中直升天国。 似水流年标注(黄色) - 位置 2086 似水流年是一个人所有的一切，只有这个东西，才真正归你所有。其余的一切，都是片刻的欢娱和不幸，转眼间就已跑到那似水流年里去了。 标注(黄色) - 位置 2101 这个故事告诉我们，随着医学的发展，干点缺德事不要紧，生孩子没屁眼可以做人工肛门，怕什么？","link":"/2021/01/03/%E3%80%8A%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3%E3%80%8B%E4%B9%A6%E6%91%98/"},{"title":"基金定投指南书摘","text":"最近开始拿工资做定投，感觉再像以前一样乱买一通不太好，想要系统化的学习，于是拜读了《指数基金投资指南》这本书，感觉还是有一些可以分享的内容，这里选出我认为有用的书摘和我的见解，仅供参考。 先评价 这本书我整体只能打四分，前面很浮夸，中间大段大段的介绍各种基金是什么，结尾是我最讨厌的读者来信。不过在其中还是有一些可以分享的内容可以挑选出来。 正文序言 股神巴菲特说“通过定期投资指数基金，一个什么都不懂的业余投资者竟然往往能够战胜大部分专业投资者”； 就这句话一本书出现了不止十次，噱头十足。 指数基金的优点 1.指数基金“长生不老”因为没有一家公司可以长生不老，但是指数基金可以通过吸收新公司替换老公司的方法，实现长生不老。理论上，指数的寿命与国家的寿命等同。 这里我就很迷惑，长生不老是啥优点吗，还能祖传股票的吗。 2.指数基金能长期上涨 我们举个例子，港股对应的指数是恒生指数，是1964年诞生的，最初恒生指数点数是100点。前面也提到过，指数的点数代表可以看作指数包括的股票的股价。到2017年6月初，恒生指数涨到了26 000点，在53年里上涨了200多倍。 这个恒生指数的例子后面还会出现十几次，为什么拿恒生举例子呢，应该是美股历史太悠久，A股从发行也没涨几倍，这个最合适了，把这个股市最繁荣的一段拿出来说。 3.指数基金成本低 这里说的是基金管理费用低，不过我不清楚炒股的管理费用，就不评价了。 第三章：常见指数基金类型 后面就是大段的介绍各种各样的指数，都算是基本概念，有些看名字就知道是啥基金了。其中比较有意思的是红利指数，里面都是分红率比较高的公司。从现在看权重比较大的都是各种国企和银行。 H股，指内地公司在港上市的股。因为可能两地上市就产生了有趣的H股优选基金。就是买入同一家公司在两地中价格较低的股票，因为即使是在两地，公司的价值评估也总会趋近相同。 第四章：如何挑选合适的基金 价格与价值的关系 股价就像一只跟着主人散步的小狗。主人沿着马路前进，小狗一会跑到主人前面，一会儿又落后于主人。但最终主人到目的地时，小狗也会到。 后面介绍市盈率市净率等等指标，很基础的概念但是也很重要。后面做价值评估会用到。 盈利收益率法挑选指数基金 当盈利收益率大于10%时，开始定投。 当盈利收益率低于6.4%时，暂停定投。 博格公式：指数基金的收益公式 指数基金未来的年复合收益率，等于指数基金的投资初期股息率，加上指数基金每年的市盈率变化率，再加上指数基金的每年的盈利变化率。 第5章如何买卖指数基金：懒人定投法 博格公式法＋定投。·在市盈率或市净率处于历史底部区域的时候坚持定投。·市盈率市净率进入正常估值，暂停定投，继续持有；可以定投其他处于底部区域的品种。·当市盈率市净率进入历史较高区域的时候卖出。 后面开始介绍场内基金和场外基金的区别。有兴趣请自行查询。 介绍每个月应该定投多少钱，我就直接使用了支付宝的价值均线策略。 （ 4 ）经验和心得 ① 定投不一定马上赚钱，而且很多时候是会亏钱的，但定投要坚持下去，不要因为一时的亏损就放弃。 ② 定投基金不是傻傻地一直定投下去，止盈是一件非常重要的事情。 ③ 定投亏损不可怕，最怕的是中途因为没赚钱而放弃。 ④ 不要在中途中有一点点的盈利就落袋为安，只有到了设定的盈利时才逐步退出。 后两章包括读者来信和家庭资产配置，略过。 第8章长期投资的心理建设 日本指数给我们两个启示：一是投资指数基金的时候，要在低估时投资，如果在高估的时候买入，收益不会好；二是即使在低估买入，国家经济发展的好坏，也会极大地影响最后的收益。“买指数就是买国运”，这句话还是非常有道理的。相信中国经济会持续发展走好，这就是我们投资指数基金的最大信心来源。 之前在论坛看到有一个提问，说就算你天天定投基金，但是基金天天都跌，一样也没法盈利。对应这个问题我一直也想不通，看了整本书我也就明白了。买基金，尤其是买指数基金就是买国运，如果国家一年不如一年，上证天天跌，我觉得你投资什么都区别不大。买指数基金，当国家经济上涨是可以分得一杯羹。 巴菲特的卖出三条件 基本面恶化对指数基金来说，基本面跟一个国家的宏观经济密切相关。如果相信一个国家经济能长期崛起，那对应的指数基金的基本面也会随之向上。所以这个标准国内的指数基金一般用不上，主要是依据后两个卖出。 过于昂贵当指数基金估值过高的时候，它就变得“昂贵”了。例如2007年，当时国内的指数基金，市盈率估值基本都是40+了。到了过于昂贵的时候可以卖出，换成其他的资产大类（例如合适的房地产、债券基金、理财等品种）。书中前面提到的“盈利收益率低于6.4%卖出”“指数基金进入自身历史高估值卖出”等，都是基于这一标准。有更好的品种有的时候，我们持有的指数基金估值正常，但出现了跟持有的品种类似、却更便宜的品种。例如上证50指数与H股指数，有的时候上证50指数远比H股指数估值低，有的时候却反过来。所以如果出现了远比手里持有的基金更便宜的品种，是可以卖出换过去的。 最后是我的一点感想。同样一个基金，之前买能挣钱，再入手就亏了，这就是不考虑价值乱买的结果。其实我买基金跟书中提到的一样，买了一点小钱，看到涨了，于是又买了大笔，然后就套牢了。 我也正是因为套牢而来想着研究一下基金的。虽然现在还是套牢了几个点，不过这一次我要放平心态了，克服人性里的追涨杀跌。昨天看到一篇报道提到了基金收益的分步，即使是一只几年涨百分之三百的基金，也有近一半人是亏损的，只有百分之一的人可以收益100%。理性在投资里太难了。 其中，频繁买卖的用户较拿着不动的用户收益率相对少28%；追涨杀跌用户较基金自然净值涨幅少赚40%。截至2020年7月，基民中35%的用户买入后不到一个月就会清仓，能赚钱的不到6成。只有38%的用户持仓一年以上，但近9成都能赚到钱。 中欧基金在2019年的一则分析中也指出，其旗下某基金产品三年来涨幅达到55.42%，较同期中证500的超额收益达到81.28%。在此前任意时点买入并持有2年就一定能获得正收益，平均收益率达43.88%。但该基金投资者平均收益仅8%，买了该基金亏钱的用户也大有人在。 类似的案例在基金公司中屡见不鲜。作者从一家大型基金公司了解到，今年初统计中，某基金产品2013年到2019年累计收益超过300%，期间只有2018年收益为负。但曾经持有的客户中有近40%都亏损，真正实现100%以上收益的客户只有1%。 全文在这里 https://mp.weixin.qq.com/s/0Cj-ZFu7uRQE9MWrHgsMlg END","link":"/2020/09/22/%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E6%8C%87%E5%8D%97%E4%B9%A6%E6%91%98/"},{"title":"如何从Edge迁移Firefox","text":"如果你厌倦了Edge和Chrome，可以来试试Firefox。 下载与安装 记得一定要下载国际版本：https://www.mozilla.org/zh-CN/firefox/new/ iOS版本登录不要选择本地同步服务服务，保证使用的都是国际服务器。 书签和密码可以直接导入，很简单的。 我的常用插件适配情况 插件名称 适配情况 是否需要备份 功能简介 Dark Reader 适配 No 黑暗模式 RSSHub Radar 适配 No RSS发现 http://raindrop.io/ 适配 No 稍后读 Vimium C - 全键盘操作浏览器 适配 Yes Vim uBlock Origin 适配 No 广告屏蔽 暴力猴 适配 Yes 脚本 OneTab 适配 Yes 稍后读 Stylus 适配 Yes 网页样式 划词翻译 - 简单好用的划词与截图翻译扩展 适配 No 翻译 PT Plugin Plus 未适配 Yes PT插件 小基助手 - 时刻关注你的基金 未适配 Yes 基金 下载+ 未适配 No 下载管理 简悦 - SimpRead 未适配 No 阅读模式 Firefox的优点 名称 感知程度 固定标签页的逻辑：固定标签页——让最爱的网站保持打开且只需一次点击就可访问 高 侧边栏，尤其是树状标签页 高 多设备的标签页同步：应该是除了苹果全家桶体验最好的 高 开发者工具优秀 高 隐私保护，作为一个非盈利机构，从本质上就和Google的Chrome不同 中 多用户环境隔离，可以多账户登录同一个网站 中 密码管理方便，支持按使用顺序查看 低 书签原生支持分割条 低 多搜索引擎搜索支持，搜索框直接关键字切换搜索引擎，支持直接搜索书签和历史 高 Firefox的缺点 名称 感知程度 没有单个网页的js禁用选项 中 部分插件不支持 中 UI简陋 低 密码查看存在安全隐患 低 书签栏的书签不能一键隐藏名字 低 书签和历史记录UI简陋 低 遇到的问题 部分书签隐藏名称：未解决，可以通过修改配置文件来处理，太麻烦 书签不需要全部打开：无所谓了，有时候还是有用的 全局翻译：没有全局翻译，各种翻译插件都不是很理想，可以先使用这个：https://addons.mozilla.org/firefox/addon/traduzir-paginas-web 上手资料键盘快捷键 非常建议你看一遍Firefox的所有新手指引，写的非常详细。 因为最近换了新电脑，所以最近会更新一篇Windows从头开始装软件的文章，敬请期待:) END","link":"/2021/04/14/%E5%A6%82%E4%BD%95%E4%BB%8EEdge%E8%BF%81%E7%A7%BBFirefox/"},{"title":"GitHub Page 我又回来啦","text":"迫于服务器没钱续费，我又回到GitHub Page的怀抱了如果不出意外的话，之后都不会换博客位置了，就是这域名还是有可能换的，毕竟域名也是要钱的哈哈。 暂时把之前写的博文传上来，至于后面什么时候写新的我也不知道了。 后面我的博文可能会以各种软件的试用为主，包含生活中的折腾。 ps：这次我会注意大小写和符号问题的。之前的文章咱就不改了，偷下懒嘻嘻","link":"/2020/06/09/%E6%88%91%E5%8F%88%E5%9B%9E%E6%9D%A5%E5%95%A6/"},{"title":"效率工具小测：Listary Wox uTools","text":"预期功能 快速准确的文件和程序搜索 可以安装插件，具备一定的扩展性能 UI不能非常难看，配置不要过于复杂 Listary（beta 6.0.5.16） 因为基于最新测试版本，以下内容均有可能发生改变 优点 超快的文件查找速度，并且不依赖Everything 基于文件类型的搜索，并且支持自定义 UI美观，设置界面简洁 缺点 基于beta版本没有插件，鼠标中间的历史文件等功能存在问题 6.0版本更新缓慢，核心功能缺失，Bug较多，不建议使用beta版本 beta版无法关闭文件夹双击触发菜单的功能 Listary（5.00.2843） 优点 文件搜索速度快 软件发布时间长，应该较为稳定 缺点 UI复杂，没有beta好看 主要功能与文件搜索相关，没有其他太多功能 具有不少自定义功能，但是需要自行研究 搜索时不如beta流程和美观 Listary小结等待beta版本稳定之后再尝试，现在旧版本不更新，新版本更新速度和质量都存在问题，核心功能还不稳定，不建议正式使用。 Wox 优点 软件更新速度快，基本每几天发布一个新版本，无序担心后期的维护问题 具有插件功能，有官方插件库，大约有两百多个插件 缺点 设置界面的UI非常简陋，应该是这三款中最简陋的一个 搜索功能依赖Everything，搜索不能进行控制和后续操作（对比Listary） 搜索速度慢，如果是搜索程序，甚至需要等待加载，一些程序的搜索结果很奇怪，比如搜索ff，排在首位的居然是Office，不知道这是啥逻辑 环境需要依赖Python Wox小结相较于Listary搜索功能更差，需要依赖其他软件和环境，并且搜索结果不准确，优点在于具有很多的插件可以使用，如果有部分插件可以解决痛点，还是可以试一试的，不过个人不是很推荐。 utools 优点 最大的优点：丰富多样的插件，例如正则测试，json格式化等等插件可以选择。 已经开始收费，后期更新较为稳定。 UI简洁好看，插件安装与使用简单。 超级面板功能，语言输入等。 缺点 数据同步需要会员，小问题。 总结如果是需要一个搜索文件的工具，那么可以试一试Listary的beta版，等待后续稳定肯定是不错的。如果需要的是一个效率工具，那么我更推荐utools，各种丰富的插件总能满足了。这次的效率工具大折腾到此结束了，等之后Listary更新再尝试一下。","link":"/2021/04/11/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E5%B0%8F%E6%B5%8B%EF%BC%9AListary%20Wox%20uTools/"},{"title":"新poker键盘简单上手与配置","text":"迫于最近打字比较多，但是笔记本打字实在太难受，冲着便携的角度入了一个60%配列的新poker，分享一下这一天折腾的效果。 为什么买 因为之前只用过富勒的红轴和filco的青轴，所以还是想入一个大厂的红轴体验一下区别（买红轴为了办公室保命），实测噪音还是非常小的，小于二档的电风扇。 为了便携也是为了体验小配列，所以首先确定了60的配列。可能是因为这种键盘过于小众，所以可选择的品牌也不是很多，出于对ikbc的信任（因为这个最便宜）入了新poker一代。至于为什么不买tape-c的poker二代，因为新一代配置有点麻烦（其实还是因为穷）。 最后从闲鱼上160入手了这款键盘，目前的市场二手价新二代300左右，新二代两百左右，注意区分新二代和老二代，不要花了冤枉钱，使用c口的才是新二代。 上手 做工方面，因为之前用过的都是abs的键帽，这是第一次用pbt的键帽，感觉还是不太一样的。abs的表面是滑滑的，pbt就有点磨砂的感觉，两种材质都还可以，没啥问题。 大键方面采用的是卫星轴，拆起来真是比filco的平衡杆方便太多了。大键手感感觉还可以，就是有点空空的感觉，不知道是不是红轴的问题。 重新用回红轴，刚开始没有咯哒咯哒的声音还是不太习惯的，但是开始打字后还是挺好的。 防滑垫做的还是挺不错的，相当防滑，没有脚撑算是小遗憾。 数据线接口使用的是最老的t形口，没办法，也是老产品了。 使用 这种配列的键盘取消的f区，方向键，del区和波浪线键。如何找回这些键呢？ f1-f12使用fn加1-12即可。 方向键我是刷了独立方向键的固件，让右手边的四个键全部映射到左手，把右边空出来之后再通过硬件编程配置上方向键。 配置之后打开fn+shift切换taggle层，这一层就相当于默认带fn，这样就可以直接按右手的四个键当作方向键了。 问题：因为固件把caps也就是大写锁定键映射为fn，所以键盘上彻底没有caps键了，目前也没有找到解决方法，只能暂时先习惯了。 问题：这个固件刷了只有就用波浪线作为左上角键的默认值，如果需要esc就需要加上fn键，从我个人的使用习惯上是esc使用远远多余波浪线的，所有我直接在taggle层吧esc键映射成了esc，之后再长期打开taggle层就可以了。如果需要波浪线则先退出taggle层再使用即可。 这整套配置下来失去了大写锁定键，波浪号使用多一步，换来了可以直接使用的方向键，感觉还是挺值的。 剩下的字符编程，快捷打开文件软件什么的需要慢慢摸索了，可玩行还是不错的。 参考文档 固件的下载和刷机：https://bbs.wstx.com/thread-534633-1-1.html，这个应该是原始发帖地址，其他地方都是复制粘贴来的。 官方文档：http://www.ikbc.com.cn/Private/Files/6372299327499382571131837755.pdf ps：这篇文就是用poker打的，感觉还是很顺畅的。 end","link":"/2020/07/06/%E6%96%B0poker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B%E4%B8%8E%E7%BC%96%E7%A8%8B%E9%85%8D%E7%BD%AE/"},{"title":"稍后读服务对比","text":"需求 多端同步，手机端使用合理 保存网页简单，手机端可以分享收藏，浏览器端通过插件收藏 便捷的批量打开收藏，最好支持后台打开，支持批量删除 支持多种排序，最好支持按网站排序，读起来具有连贯性 文章分类管理功能 对比产品 Pocket Instappaer Raindrop.io 对比 同步功能：三者对比体验相似，在国内环境下使用均无明显缺点。但是instapaper在国区Apple Store无法下载，为小缺点，其余两家正常。 保存功能：Instapaper和Raindrop在Firefox上都有插件可以使用，Pocket是Firefox原生支持的，使用起来更方便。 批量打开：Instapaper和Pocket后台打开都是转码后的网页，不能直接跳转到原网页，对于转码效果不好的网站需要多进行一步跳转，而Raindrop是支持点击直接跳转到原网址的。 排序功能：Instapaper没找到排序功能，Pocker有按时间排序的功能，Raindrop最全，有按时间，按网站，按名称排序三种方式，其中按网站排序非常好用。 分类管理：Instapaper只有按文件夹分类，不可嵌套，官方还区分了喜欢、文章、视频等分区。Pocket支持按标签分类，相比之下更灵活，官方划分了喜欢、高亮、视频、文章等分区。Raindrop同时具有标签和文件夹管理，升级会员之后还支持文件夹嵌套功能，管理方面最为全面。 各自特点 Pocket：Firefox的原生支持是对我的最大吸引力了，支持在页面右键直接收藏到Pocket，非常的方便。 Instapaper：输出文章到Kindle阅读，对于习惯使用kindle来阅读的小伙伴很有吸引力。 Raindrop：支持中文，文章支持多种排序，支持多种文章查看方式，可以设置双列打开文章查看，也可以一键打开原网址。 总结 稍后读软件用了好多年了，本来一直是用的Pocket，在上面也积累了上百个标签了，但是后面标签越来越多的情况下管理起来愈发的困难，所以正好接着这次换服务的计划小评了一下市面上常见的稍后读服务软件，其实还有好几个其他竞争者，比如苹果自带的阅读列表，在全苹果生态下使用相当便捷，但是没有最基础的管理功能，也不支持Windows平台，注定不是很通用，只能可以作为文章的中转站。前段时间还使用了cubox，算是最近的新秀，支持自定义过滤列表，不错的UI，支持全平台，但是没有会员的情况下只有一百条的限制还是太低了，作为一个新生的服务类网站贸然的去使用风险还是过高。 综合比较下来目前还是推荐Raindrop，在使用上基本没有遇到过什么缺点，之前较差的服务速度也又大大的改善，之前手机端的保存过于慢也在更新中解决了，也支持直接导出，不用担心跑路问题，还是推荐一试的，我也会最近开始迁移之前的文章了。不过最后提醒一下，稍后读最重要的还是自己去读，再好的服务如果不读也是白费劲。 小短文就不分页了，直接看就好。 END","link":"/2021/05/12/%E7%A8%8D%E5%90%8E%E8%AF%BB%E6%9C%8D%E5%8A%A1%E5%AF%B9%E6%AF%94/"},{"title":"黑客与画家-书摘","text":"黑客与画家:硅谷创业之父Paul Graham文集 Kindle edition. 一百年后的编程语言 现在，我们的两个观点就是：（1）一百年后的编程语言在理论上今天就能设计出来；（2）如果今天真能设计出这样一种语言，很可能现在就适合编程，并且能够产生更好的结果。如果我们把这两个观点联系起来，那就得出了一些有趣的可能性。为什么不现在就动手尝试写出一百年后的编程语言呢？ 拒绝平庸 在Viaweb创业期间，我读过大量竞争对手的招聘职位。差不多每个月都有一个新的竞争对手浮出水面。我首先会看他们的产品有没有一个试用版，然后就去找他们的招聘职位。这样过了几年，我就知道哪些公司值得关注，哪些公司不用在意。有些公司的职位描述使用了大量的IT词汇，这样的内容越多，这家公司就越不构成威胁。最不用担心的竞争对手就是那些要求应聘者具有Oracle数据库经验的公司，你永远不必担心他们。如果是招聘C++或Java程序员的公司，对你也不会构成威胁。如果他们招聘Perl或Python程序员，就稍微有点威胁了。至少这听起来像一家技术公司，并且由黑客控制。如果我有幸见到一家招聘Lisp黑客的公司，就会真的感到如临大敌。 梦寐以求的编程语言 黑客欣赏的一个特点就是简洁。黑客都是懒人，他们同数学家和现代主义建筑师一样，痛恨任何冗余的东西或事情。有一个笑话说，黑客动手写程序之前，至少会在心里盘算一下哪种语言的打字工作量最小，然后就选择使用该语言。这个笑话其实与真实情况相差无几。就算这真的是个笑话，语言的设计者也必须把它当真，按照它的要求设计语言。简洁性最重要的方面就是要使得语言更抽象。为了达到这一点，首先你设计的必须是高级语言，然后把它设计得越抽象越好。语言设计者应该总是看着代码，问自己能不能使用更少的语法单位把它表达出来。如果你有办法让许多不同的程序都能更简短地表达出来，那么这很可能意味着你发现了一种很有用的新抽象方法。 一种真正优秀的编程语言应该既整洁又混乱。“整洁”的意思是设计得很清楚，内核由数量不多的运算符构成，这些运算符易于理解，每一个都有很完整的独立用途。“混乱”的意思是它允许黑客以自己的方式使用。C语言就是这样的例子，早期的Lisp语言也是如此。真正的黑客语言总是稍微带一点放纵不羁、不服管教的个性。 用户是一把双刃剑。他们推动语言的发展，但也使得你不敢对语言进行大规模改造。所以，一开始的时候要精心选择用户，避免使用者过快增长。发展用户就像一种优化过程，明智的做法就是放慢速度。一般情况下，用户比较少意味着你任何时候都可以加大修改的力度。这时，对语言规格做出改变就像撕绷带，当你感到痛苦的一瞬间，痛苦就已经成为了回忆。如果用户数量庞大，修改语言带来的痛苦就将持续很长时间。 梦寐以求的编程语言让我们试着描述黑客心目中梦寐以求的语言来为以上内容做个小结。这种语言干净简练，具有最高层次的抽象和互动性，而且很容易装备，可以只用很少的代码就解决常见的问题。不管是什么程序，你真正要写的代码几乎都与你自己的特定设置有关，其他具有普遍性的问题都有现成的函数库可以调用。这种语言的句法短到令人生疑。你输入的命令中，没有任何一个字母是多余的，甚至用到Shift键的机会也很少。这种语言的抽象程度很高，使得你可以快速写出一个程序的原型。然后，等到你开始优化的时候，它还提供一个真正出色的性能分析器，告诉你应该重点关注什么地方。你能让多重循环快得难以置信，并且在需要的地方还能直接嵌入字节码。这种语言有大量优秀的范例可供学习，而且非常符合直觉，你只需花几分钟阅读范例就能领会应该如何使用此种语言。你偶尔才需要查阅操作手册，它本身很薄，里面关于限定条件和例外情况的警告寥寥无几。这种语言的内核很小，但很强大。各个函数库高度独立，而且和内核一样经过精心设计，它们都能很好地协同工作。语言的每个部分就像精密照相机的各种零件一样完美契合，不需要为了兼容性问题放弃或者保留某些功能。所有函数库的源码都很容易得到。这种语言能够很轻松地与操作系统和用其他语言开发的应用程序对话。这种语言以层的方式构建。较高的抽象层透明地构建在较低的抽象层之上。如果需要的话，你可以直接使用较低的抽象层。除了一些绝对必要隐藏的东西，这种语言的所有细节对使用者都是透明的。它提供的抽象能力只是为了方便你的开发，而不是为了强迫你按照它的方式行事。事实上，它鼓励你参与它的设计，给你提供与语言创造者平等的权力。你能够对它的任何部分加以改变，甚至包括它的语法。它尽可能让你自己定义的部分与它本身定义的部分处于同等地位。这种梦幻般的编程语言不仅开放源码，更开放自身的设计。","link":"/2020/06/22/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6-%E4%B9%A6%E6%91%98/"},{"title":"迁移到Hexo中遇到的坑&amp;Hexo常用的命令","text":"记录迁移到Hexo中遇到的一些坑。 NexT的主题设置语言修改的是Hexo的配置文件中的language: zh-CN，而不是官方文档上说的zh-hans，具体为什么不清楚。 Next设置阅读全文，建议在文章中添加&lt;!-- more--&gt;。 Hexo添加标签页和分类页请使用hexo new pge tags和hexo new page categories，并且在文件的分割线上方添加type: tags 和 type: categories，之后在每个文章的分割线上正常添加对应tags和categories即可。最后在主题配置文件的menu下配置上需要使用的菜单即可。 Hexo常用的命令 hexo clean 清除缓存 hexo g 生成 hexo s 运行在本地环境提供预览 hexo d 部署 关于push一直需要密码，请输入git config --global credential.helper store hexo new 文章名 新建文章 这里是NexT的官方网站： http://theme-next.iissnan.com/ 这个是Hexo的官方网站：https://hexo.io/zh-cn/ 吐槽：不知道NexT的目录分级是怎么分的，感觉都乱掉了，不知道是不是我写的有问题。","link":"/2020/06/22/%E8%BF%81%E7%A7%BB%E5%88%B0hexo%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"title":"Java编程思想第六更","text":"我又又又鸽了一转头又鸽了半个月的更新，不得不说sorted的推迟功能可真方便，天天下午就点一下，总感觉明天再看，明天再写，不行可以星期六再写，事实上还是没写，CK3真好玩不多BB了，明天再继续写一点。 1.11 Java 和因特网1.11.1 什么是 Web ？1.11.2 客户端编程 介绍了客户端服务端的关系，介绍Web的基础情况，都是写基本概念，请自行查看。另外ActiveX是个啥东西，这书也太古老了吧 1.11.3 服务器端编程 我们的整个讨论都忽略了服务器端编程的问题。如果向服务器发出一个请求，会发生什么事情？大多数时候的请求都是很简单的一个“把这个文件发给我”。浏览器随后会按适当的形式解释这个文件：作为HTML 页、一幅图、一个Java 程序片、一个脚本程序等等。向服务器发出的较复杂的请求通常涉及到对一个数据库进行操作（事务处理）。其中最常见的就是发出一个数据库检索命令，得到结果后，服务器会把它格式化成HTML页，并作为结果传回来。 另外，有时需要在数据库中注册自己的名字（比如加入一个组时），或者向服务器发出一份订单，这就涉及到对那个数据库的修改。这类服务器请求必须通过服务器端的一些代码进行，我们称其为“服务器端的编程”。在传统意义上，服务器端编程是用Perl 和 CGI脚本进行的，但更复杂的系统已经出现。其中包括基于Java 的 Web服务器，它允许我们用Java进行所有服务器端编程，写出的程序就叫作“小服务程序”（Servlet）。 1.11.4 一个独立的领域：应用程序注：以下内容包含大量程序开发设计与分析的内容，没有具体的经历也谈不出自己的想法，只能先贴原文。 1.12 分析和设计 最好的入门书仍然是Grady Booch 的《Object-Oriented Design withApplications，第2 版本》，学习OOP思想。 1.12.1 不要迷失 在整个开发过程中，最重要的事情就是：不要将自己迷失！但事实上这种事情很容易发生。大多数方法都设计用来解决最大范围内的问题。当然，也存在一些特别困难的项目，需要作者付出更为艰辛的努力，或者付出更大的代价。但是，大多数项目都是比较“常规”的，所以一般都能作出成功的分析与设计，而且只需用到推荐的一小部分方法。但无论多么有限，某些形式的处理总是有益的，这可使整个项目的开发更加容易，总比直接了当开始编码好！ 也就是说，假如你正在考察一种特殊的方法，其中包含了大量细节，并推荐了许多步骤和文档，那么仍然很难正确判断自己该在何时停止。时刻提醒自己注意以下几个问题： (1) 对象是什么？（怎样将自己的项目分割成一系列单独的组件？）(2) 它们的接口是什么？（需要将什么消息发给每一个对象？） 1.12.2 阶段 0：拟出一个计划 但很常见的一种情况是：有些人甚至没有进入阶段 1，便忙忙慌慌地开始编写代码。如果你的计划本来就是“直接开始开始编码”，那样做当然也无可非议（若对自己要解决的问题已有很透彻的理解，便可考虑那样做）。但最低程度也应同意自己该有个计划。 从很多地方都提到过编码需要先思考好计划再动手。 在这个阶段，可能要决定一些必要的附加处理结构。但非常不幸，有些程序员写程序时喜欢随心所欲，他们认为“该完成的时候自然会完成”。这样做刚开始可能不会有什么问题，但我觉得假如能在整个过程中设置几个标志，或者“路标”，将更有益于你集中注意力。 这恐怕比单纯地为了“完成工作”而工作好得多。至少，在达到了一个又一个的目标，经过了一个接一个的路标以后，可对自己的进度有清晰的把握，干劲也会相应地提高，不会产生“路遥漫漫无期”的感觉。 比起漫无目的的编码，先设定一些小目标会更加好。例如先完成某个API的内容，最后将其整合。 1.12.3 阶段 1：要制作什么？ 需求分析的意思是“建立一系列规则，根据它判断任务什么时候完成，以及客户怎样才能满意”。系统规格则表示“这里是一些具体的说明，让你知道程序需要做什么（而不是怎样做）才能满足要求”。需求分析实际就是你和客户之间的一份合约（即使客户就在本公司内部工作，或者是其他对象及系统）。系统规格是对所面临问题的最高级别的一种揭示，我们依据它判断任务是否完成，以及需要花多长的时间。由于这些都需要取得参与者的一致同意，所以我建议尽可能地简化它们——最好采用列表和基本图表的形式——以节省时间。可能还会面临另一些限制，需要把它们扩充成为更大的文档。 我们特别要注意将重点放在这一阶段的核心问题上，不要纠缠于细枝末节。这个核心问题就是：决定采用什么系统。对这个问题，最有价值的工具就是一个名为“使用条件”的集合。 1.12.4 阶段 2：如何构建？ 在这一阶段，必须拿出一套设计方案，并解释其中包含的各类对象在外观上是什么样子，以及相互间是如何沟通的。此时可考虑采用一种特殊的图表工具：“统一建模语言”（UML）。 1.12.5 阶段 3：开始创建 读这本书的可能是程序员，现在进入的正是你可能最感兴趣的阶段。由于手头上有一个计划——无论它有多么简要，而且在正式编码前掌握了正确的设计结构，所以会发现接下去的工作比一开始就埋头写程序要简单得多。而这正是我们想达到的目的。 让代码做到我们想做的事情，这是所有程序项目最终的目标。但切不要急功冒进，否则只有得不偿失。根据我的经验，最后先拿出一套较为全面的方案，使其尽可能设想周全，能满足尽可能多的要求。 给我的感觉，编程更象一门艺术，不能只是作为技术活来看待。所有付出最终都会得到回报。作为真正的程序员，这并非可有可无的一种素质。全面的思考、周密的准备、良好的构造不仅使程序更易构建与调试，也使其更易理解和维护，而那正是一套软件赢利的必要条件。 构建好系统，并令其运行起来后，必须进行实际检验，以前做的那些需求分析和系统规格便可派上用场了。全面地考察自己的程序，确定提出的所有要求均已满足。现在一切似乎都该结束了？是吗？ 只要开发前有写过设计，那么编码就会简化的多。 1.12.6 阶段 4：校订 事实上，整个开发周期还没有结束，现在进入的是传统意义上称为“维护”的一个阶段。“维护”是一个比较暧昧的称呼，可用它表示从“保持它按设想的轨道运行”、“加入客户从前忘了声明的功能”或者更传统的“除掉暴露出来的一切臭虫”等等意思。所以大家对“维护”这个词产生了许多误解，有的人认为：凡是需要“维护”的东西，必定不是好的，或者是有缺陷的！因为这个词说明你实际构建的是一个非常“原始”的程序，以后需要频繁地作出改动、添加新的代码或者防止它的落后、退化等。因此，我们需要用一个更合理的词语来称呼以后需要继续的工作。 什么时候才叫“达到理想的状态”呢？这并不仅仅意味着程序必须按要求的那样工作，并能适应各种指定的“使用条件”，它也意味着代码的内部结构应当尽善尽美。至少，我们应能感觉出整个结构都能良好地协调运作。没有笨拙的语法，没有臃肿的对象，也没有一些华而不实的东西。除此以外，必须保证程序结构有很强的生命力。由于多方面的原因，以后对程序的改动是必不可少。但必须确定改动能够方便和清楚地进行。 1.13 Java 还是 C++？ 原文认为Java是不会取代C++的最重要的原因就是Java的速度比C++慢，计算机最重要的就是执行速度。 第 2 章 一切都是对象 注：看了几个月了，可算是看到第二章了，我这也太鸽了。 “尽管以C++为基础，但 Java 是一种更纯粹的面向对象程序设计语言”。无论C++还是Java 都属于杂合语言。但在 Java 中，设计者觉得这种杂合并不象在 C++里那么重要。杂合语言允许采用多种编程风格；之所以说 C++是一种杂合语言，是因为它支持与 C语言的向后兼容能力。由于C++是C的一个超集，所以包含的许多特性都是后者不具备的，这些特性使 C++在某些地方显得过于复杂。Java 语言首先便假定了我们只希望进行面向对象的程序设计。也就是说，正式用它设计之前，必须先将自己的思想转入一个面向对象的世界（除非早已习惯了这个世界的思维方式）。只有做好这个准备工作，与其他OOP语言相比，才能体会到 Java 的易学易用。在本章，我们将探讨 Java 程序的基本组件，并体会为什么说Java 乃至Java 程序内的一切都是对象。 疑问：为什么说允许采用多种编程风格就是咋合语言，编程风格不是会有程序员决定的吗？ 2.1 用句柄操纵对象 每种编程语言都有自己的数据处理方式。有些时候，程序员必须时刻留意准备处理的是什么类型。您曾利用一些特殊语法直接操作过对象，或处理过一些间接表示的对象吗（C 或C++里的指针）？ 所有这些在 Java 里都得到了简化，任何东西都可看作对象。因此，我们可采用一种统一的语法，任何地方均可照搬不误。但要注意，尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“句柄”（Handle）。 在其他 Java 参考书里，还可看到有的人将其称作一个“引用”，甚至一个“指针”。 可将这一情形想象成用遥控板（句柄）操纵电视机（对象）。只要握住这个遥控板，就相当于掌握了与电视机连接的通道。但一旦需要“换频道”或者“关小声音”，我们实际操纵的是遥控板（句柄），再由遥控板自己操纵电视机（对象）。如果要在房间里四处走走，并想保持对电视机的控制，那么手上拿着的是遥控板，而非电视机。 句柄这个翻译真的是一言难尽，虽然被C语言的指针搞吐了，但是我认为指针是好的翻译，指代表了这个物体天然具有指向的属性，针可以形容这个物体的相对于被指向的物体很小。 不过Java中比较常用的还是引用这个词，关于引用和指针的区别，我在知乎上找到的回答大部分认为指针是一种非常灵活自由的物体，而引用则是牺牲了效率而换来了安全，算是一种指针的指针。例如指针甚至可以直接操作内容。 此外，即使没有电视机，遥控板亦可独立存在。也就是说，只是由于拥有一个句柄，并不表示必须有一个对象同它连接。所以如果想容纳一个词或句子，可创建一个 String句柄：String s;但这里创建的只是句柄，并不是对象。若此时向s 发送一条消息，就会获得一个错误（运行期）。这是由于s实际并未与任何东西连接（即“没有电视机”）。因此，一种更安全的做法是：创建一个句柄时，记住无论如何都进行初始化。 引用当然可以单独存在，不然可就没有空指针异常了。空指针异常是存在于运行期的异常，一般都是编程出现了漏洞或者错误。很难说每个引用都要初始化，但是使用前一定要确保已经进行了初始化。 2.2 所有对象都必须创建 创建句柄时，我们希望它同一个新对象连接。通常用new 关键字达到这一目的。new的意思是：“把我变成这些对象的一种新类型”。所以在上面的例子中，可以说：String s = new String(“asdf”);它不仅指出“将我变成一个新字串”，也通过提供一个初始字串，指出了“如何生成这个新字串”。当然，字串（String）并非唯一的类型。Java 配套提供了数量众多的现成类型。对我们来讲，最重要的就是记住能自行创建类型。 2.2.1 保存到什么地方 (1) 寄存器。这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。 (2) 堆栈。驻留于常规 RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管有些Java 数据要保存在堆栈里——特别是对象句柄，但Java 对象并不放到其中。 (3) 堆。一种常规用途的内存池（也在 RAM区域），其中保存了Java 对象。和堆栈不同，“内存堆”或“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！ (4) 静态存储。这儿的“静态”（Static）是指“位于固定位置”（尽管也在 RAM里）。程序运行期间，静态存储的数据将随时等候调用。可用static 关键字指出一个对象的特定元素是静态的。但 Java 对象本身永远都不会置入静态存储空间。 (5) 常数存储。常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM） (6) 非RAM 存储。若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复成普通的、基于RAM的对象。 其中对程序员最重要的算是栈和堆了，这两个东西的名字都挺混乱的。同时栈和堆也是Java中的一种数据结构。 静态的可以是类，方法，字段等，正因为其存储的地方与类不同，创建的时间也与类不同，所以在使用上具有相当大的差异。 2.2.2 特殊情况：主要类型 有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主”（Primitive）类型，进行程序设计时要频繁用到它们。之所以要特别对待，是由于用 new创建对象（特别是小的、简单的变量）并不是非常有效，因为new将对象置于“堆”里。对于这些类型，Java 采纳了与 C和 C++相同的方法。也就是说，不是用new创建变量，而是创建一个并非句柄的“自动”变量。这个变量容纳了具体的值，并置于堆栈中，能够更高效地存取。Java 决定了每种主要类型的大小。就象在大多数语言里那样，这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是 Java 程序具有很强移植能力的原因之一。 在程序中有一些非常常用的类型，如果使用new的方式将其存储在堆中就会影响使用效率，所以对于这类常用的类型是可以直接存放与栈当中的。这些类型就是各种长度的浮点数定点数和布尔值加上char和void； 主数据类型也拥有自己的“封装器”（wrapper）类。这意味着假如想让堆内一个非主要对象表示那个主类型，就要使用对应的封装器。 这段说的可真绕，对于刚刚提到的类型可以称之为基本类型，而基本类型都是将值直接存储与栈中，如果需要在堆中使用基本类型就需要为基本类型在堆中准备相对应的基本类型。关于基本类型和包装类的区别这本书后面应该会有提及。 2.2.3 Java 的数组 几乎所有程序设计语言都支持数组。在C和 C++里使用数组是非常危险的，因为那些数组只是内存块。若程序访问自己内存块以外的数组，或者在初始化之前使用内存（属于常规编程错误），会产生不可预测的后果。 我相信每一个C语言的初学者都应该有被数组越界支配的恐惧。 Java 的一项主要设计目标就是安全性。所以在C 和 C++里困扰程序员的许多问题都未在Java 里重复。 一个Java 可以保证被初始化，而且不可在它的范围之外访问。由于系统自动进行范围检查，所以必然要付出一些代价：针对每个数组，以及在运行期间对索引的校验，都会造成少量的内存开销。但由此换回的是更高的安全性，以及更高的工作效率。为此付出少许代价是值得的。创建对象数组时，实际创建的是一个句柄数组。而且每个句柄都会自动初始化成一个特殊值，并带有自己的关键字：null（空）。一旦 Java 看到null，就知道该句柄并未指向一个对象。正式使用前，必须为每个句柄都分配一个对象。若试图使用依然为null 的一个句柄，就会在运行期报告问题。因此，典型的数组错误在Java 里就得到了避免。也可以创建主类型数组。同样地，编译器能够担保对它的初始化，因为会将那个数组的内存划分成零。 如果数据没有进行初始化，则其引用就是Null，编译器会阻止你调用这个数组。 2.3 绝对不要清除对象 在大多数程序设计语言中，变量的“存在时间”（Lifetime）一直是程序员需要着重考虑的问题。变量应持续多长的时间？如果想清除它，那么何时进行？在变量存在时间上纠缠不清会造成大量的程序错误。在下面的小节里，将阐示Java 如何帮助我们完成所有清除工作，从而极大了简化了这个问题。 2.3.1 作用域 大多数程序设计语言都提供了“作用域”（Scope）的概念。对于在作用域里定义的名字，作用域同时决定了它的“可见性”以及“存在时间”。在C，C++和 Java 里，作用域是由花括号的位置决定的。 作为在作用域里定义的一个变量，它只有在那个作用域结束之前才可使用。 2.3.2 对象的作用域 Java 对象不具备与主类型一样的存在时间。用new 关键字创建一个Java 对象的时候，它会超出作用域的范围之外。 {String s = new String(“a string”);} /* 作用域的终点 */那么句柄s 会在作用域的终点处消失。然而，s指向的 String 对象依然占据着内存空间。在上面这段代码里，我们没有办法访问对象，因为指向它的唯一一个句柄已超出了作用域的边界。在后面的章节里，大家还会继续学习如何在程序运行期间传递和复制对象句柄。这样造成的结果便是：对于用new 创建的对象，只要我们愿意，它们就会一直保留下去。这个编程问题在C和C++里特别突出。看来在C++里遇到的麻烦最大：由于不能从语言获得任何帮助，所以在需要对象的时候，根本无法确定它们是否可用。而且更麻烦的是，在 C++里，一旦工作完成，必须保证将对象清除。这样便带来了一个有趣的问题。假如Java 让对象依然故我，怎样才能防止它们大量充斥内存，并最终造成程序的“凝固”呢。在C++里，这个问题最令程序员头痛。但 Java 以后，情况却发生了改观。Java 有一个特别的“垃圾收集器”，它会查找用new创建的所有对象，并辨别其中哪些不再被引用。随后，它会自动释放由那些闲置对象占据的内存，以便能由新对象使用。这意味着我们根本不必操心内存的回收问题。只需简单地创建对象，一旦不再需要它们，它们就会自动离去。这样做可防止在C++里很常见的一个编程问题：由于程序员忘记释放内存造成的“内存溢出”。 因为GC的存在，Java程序员不需要在每个对象使用之后去销毁，GC负责了这个工作。GC会根据对象是否可用去清理垃圾对象。 2.4 新建数据类型：类 如果说一切东西都是对象，那么用什么决定一个“类”（Class）的外观与行为呢？换句话说，是什么建立起了一个对象的“类型”（Type）呢？大家可能猜想有一个名为“type”的关键字。但从历史看来，大多数面向对象的语言都用关键字“class”表达这样一个意思：“我准备告诉你对象一种新类型的外观”。class 关键字太常用了，以至于本书许多地方并没有用粗体字或双引号加以强调。在这个关键字的后面，应该跟随新数据类型的名称。例如：class ATypeName {/*类主体置于这里}这样就引入了一种新类型，接下来便可用new 创建这种类型的一个新对象：ATypeName a = new ATypeName();在ATypeName 里，类主体只由一条注释构成（星号和斜杠以及其中的内容，本章后面还会详细讲述），所以并不能对它做太多的事情。 在Java中所有的东西都是对象，而对象的类型/模板就是类。 2.4.1 字段和方法 定义一个类时（我们在 Java 里的全部工作就是定义类、制作那些类的对象以及将消息发给那些对象），可在自己的类里设置两种类型的元素：数据成员（有时也叫“字段”）以及成员函数（通常叫“方法”）。 其中，数据成员是一种对象（通过它的句柄与其通信），可以为任何类型。它也可以是主类型（并不是句柄）之一。如果是指向对象的一个句柄，则必须初始化那个句柄，用一种名为“构建器”的特殊函数将其与一个实际对象连接起来（就象早先看到的那样，使用new关键字）。但若是一种主类型，则可在类定义位置直接初始化（正如后面会看到的那样，句柄亦可在定义位置初始化）。 类中存在字段和方法，字段代表静态属性，方法代表动态的可用行动。 若某个主数据类型属于一个类成员，那么即使不明确（显式）进行初始化，也可以保证它们获得一个默认值。 基本类型即使不显示的初始化也是具有默认值的，这是和引用类型的一大差别。 2.5 方法、自变量和返回值 迄今为止，我们一直用“函数”（Function）这个词指代一个已命名的子例程。但在 Java 里，更常用的一个词却是“方法”（Method），代表“完成某事的途径”。尽管它们表达的实际是同一个意思，但从现在开始，本书将一直使用“方法”，而不是“函数”。Java 的“方法”决定了一个对象能够接收的消息。通过本节的学习，大家会知道方法的定义有多么简单！方法的基本组成部分包括名字、自变量、返回类型以及主体。 在C语言中称之为函数，Java中称之为方法。网查资料认为函数独立与对象，而方法依靠与对象。所以在面向对象的Java中使用方法。 返回类型 方法名( /* 自变量列表*/ ) {/* 方法主体 */} 返回类型是指调用方法之后返回的数值类型。显然，方法名的作用是对具体的方法进行标识和引用。自变量列表列出了想传递给方法的信息类型和名称。Java 的方法只能作为类的一部分创建。只能针对某个对象调用一个方法（“静态”方法可针对类调用，毋需一个对象），而且那个对象必须能够执行那个方法调用。若试图为一个对象调用错误的方法，就会在编译期得到一条出错消息。 调用的方法必须是对象中存储并且能执行的，不然编译器会阻止你。 为一个对象调用方法时，需要先列出对象的名字，在后面跟上一个句点，再跟上方法名以及它的参数列表。亦即“对象名.方法名(自变量1，自变量2，自变量 3…)。举个例子来说，假设我们有一个方法名叫 f()，它没有自变量，返回的是类型为int的一个值。那么，假设有一个名为 a 的对象，可为其调用方法f()，则代码如下：int x = a.f(); 2.5.1 自变量列表 自变量列表规定了我们传送给方法的是什么信息。正如大家或许已猜到的那样，这些信息——如同Java 内其他任何东西——采用的都是对象的形式。因此，我们必须在自变量列表里指定要传递的对象类型，以及每个对象的名字。正如在Java 其他地方处理对象时一样，我们实际传递的是“句柄”（对于前面提及的“特殊”数据类型 boolean，char，byte，short，int，long，，float 以及double 来说是一个例外）。然而，句柄的类型必须正确。倘若希望自变量是一个“字串”，那么传递的必须是一个字串。 自变量列表常称为参数列表。参数使用的也是对象。 与C语言不同，Java中使用的是值传递，在调用方法时如果传入的是基本类型，则传入值的复制。如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。 也可以了解return 关键字的运用。它主要做两件事情。首先，它意味着“离开方法，我已完工了”。其次，假设方法生成了一个值，则那个值紧接在return 语句的后面。在这种情况下，返回值是通过计算表达式“s.length()*2”而产生的。可按自己的愿望返回任意类型，但倘若不想返回任何东西，就可指示方法返回void（空）。 若返回类型为void，则return 关键字唯一的作用就是退出方法。所以一旦抵达方法末尾，该关键字便不需要了。可在任何地方从一个方法返回。但假设已指定了一种非 void 的返回类型，那么无论从何地返回，编译器都会确保我们返回的是正确的类型。 如果一个方法的返回值是void，方法是正常从头执行到尾，则可以不写return； 如果返回值不是void，则必须返回正确的类型，否则编译器会阻止你。 到此为止，大家或许已得到了这样的一个印象：一个程序只是一系列对象的集合，它们的方法将其他对象作为自己的自变量使用，而且将消息发给那些对象。这种说法大体正确，但通过以后的学习，大家还会知道如何在一个方法里作出决策，做一些更细致的基层工作。至于这一章，只需理解消息传送就足够了。 END","link":"/2020/09/09/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%85%AD%E6%9B%B4/"},{"title":"记账软件（一）入门篇","text":"记账软件小评测 起因：最近每个月的钱不明不白的就花掉了，自己还有多少存款也不清楚，所以再次萌生了记账的想法。在高中和大学阶段是持续记账过一段时间，但是当时的花销都比较单一，存款就是现金和支付宝的余额，所以就渐渐失去记账的动力。 这里就来总结一下我最近和以前用过的记账App，给自己做一个备忘，给别人做一个参考。 选择标准，优先度由高到低 UI合理美观，操作合理。 信用卡记账功能完善，有导入账单功能更好。 多客户端，尤其是有web端加分。 全免费最好，其次接受买断制，不想使用订阅制，对广告忍受力较低。 软件寿命有保障，过于小众的和个人开发的可以尝试，但是不敢长期使用，导出无限制加分。 基金自动同步市值，仔细思考后感觉也不是很重要，只需要在卖出的时候记录一下盈亏即可。 处在正常更新，不求新功能，只求不跑路。 正式开始 以下软件只保证存在iOS版，其他平台是否存在不确定。 曾经用过的记账DailyCost： 一句话，非常适合学生使用，使用简单下拉记账，无复杂功能。适合账户单一消费单一人群。免费版足够使用，导出无限制，无压力同步。 记账城市 与其说是记账软件，更像是一款游戏。记账增加城市建筑，坚持记账增加城市登记。也是玩了几个月吧，可以一试。 最近使用MOZE 3.0 UI很好看，默认黑色主题很不错，虽然其他主题还要会员才能用。图标很美观，消费和收入看的很清楚。 对信用卡支持较好，可自定义还款日，额度，账单合并，额度共享，自动扣费。但是后两个功能需要会员。 帐号内置图标多，但是部分需要收费，这波我服。 官方教程非常丰富，基本可以无痛学习。 缺点：无会员不能导入导出账本。会员每月7元，一年70。 MoneyWiz 3 算是久闻大名，但是打开之后不注册帐号无法使用，底部大大的一条广告无法关闭，直接Pass。 Toshi财务管理 UI合理，左拉打开菜单，右拉打开预算管理，感觉是一款偏预算管理的软件。 UI非常有意思，记账的按钮是可以滑动的，屏幕左中右分别对应支出收入和转账，很有创意，另外每个页面都会有可爱的小怪物。 记账时单独页面先计算金额，可以使用加减乘除求和百分比计算，确认金额后再输入事项标签帐号等，支持类别标签帐号日期位置备注功能，循环提醒拍照功能需要会员。 Web端基本等同于手机，甚至更好用，非常好评。 一大特色是支持多个银行的帐号连接，但是很遗憾没有中国的银行。 最大的缺点是非会员只能添加两个帐号，这就基本扼杀了使用的可能性。会员19块钱一个月，128一年。 网易有钱 使用过一段时间，当时可以把银行卡和支付宝都登录上去可以自动同步消费，但是后期改功能被砍，加上底部无法去除的广告使我退坑。 beancount 简单了解了一下，是一个款命令行记账，可以安装前端可视化插件。独特的使用了复式记账，不过我普通记账都记不明白还是先不尝试了吧，有兴趣的可以试一试。 上手可以从这里开始https://byvoid.com/zhs/blog/beancount-bookkeeping-1/ 钱迹 听说安卓端非常好用，无广告启动快，但是iOS端还是比较简陋。 又重新体验了一下，基本使用没有什么问，先体验几天，或许可以成为主力。 挖财 写文查资料的时候又看到推荐，使用感受就是广告太多，五个Dock选项两个带广告，个人主页也有广告，一直引诱冲会员，无会员不能导出账单，无法接受。 Money Pro 买断制好评，但是看截图感觉UI怪怪的，但是网评很不错，有空了可以一试。 最后的选择：随手记 之前一直有听说过随手记的大名，号称功能非常完善，甚至可以在小公司记录财务，因为害怕麻烦一直也没有试用。 上手的第一影响就是启动真慢，迟早有一天因为这个弃坑，还有启动广告，UI还可以，但是有点乱，存在一部分广告但是可以关闭，布局的自定义程度很高。 使用方面，因为是本土产品，基本配置啥的无压力，就是信用卡不能设置还款日不知道为啥，在web端的信用卡中心可以找到还款日和使用额度。 在站本模板里可以找到信用账本，其中可以添加信用卡，例如交通银行信用卡需要卡号和查询密码就可以查询消费记录，其他银行有的需要银联密码，安全性未知。但是信用账本里只能添加信用卡，没办法进行记账，而记账本中也无法添加同步帐号。另外今天再去刷新就需要重新输入帐号和查询密码，过于繁琐。 高级功能中有一个功能较收益中心，里面可以填写基金和股票，还会自动更新盈亏。但是在这里的资产就不会统计进账本中，想知道总资产还需要自己手动计算，也有可能是我没找到改功能。 配置后基本看不到广告了，没有网传的那么离谱，只有右上角还有两个图标无法更换。 额外有Web端和小程序，web端记账不太行，看帐还可以。小程序端非常好用，没有特殊需求完全可以代替App端。 缺点：不开会员无法导出数据，会员入口不好找，感觉完全不缺钱的公司啊，会员入口在账本管理 上方的头像里，月会员25，年会员128，会员功能包括百人记账，更换主题，导出数据。如果不是导出数据基本用不上会员，所以默认迁移成本为25即可。 另外就是诡异的多账本功能，用了信用账本就没法把负债和资产相加计算了，使用收益中心就不能在总资产里看到了，而且入口很难找，让人费解。 最后 本来都决定使用随手记了，但是写一篇文让我对钱迹 beancount Money Pro 有产生了兴趣，后面还会尝试一下，或许就会取代随手记了呢。 本来准备每个软件的介绍都贴上图的，但是贴了两张感觉效果不是很好看，还是懒了所以后面就没有贴图了。 不少地方是需要加顿号的，但是我这个键盘被我配置的不方便输入顿号，我基本都是用逗号或者空格代替了，请见谅。或许我会补上呢 本来准备写完这篇再写一篇Java编程思想的，结果一篇写了我快两个小时，只能看看明天有没有空来写了，尽量不拖更吧。 一遍过，错别字啥的有空会查。 END","link":"/2020/08/13/%E8%AE%B0%E8%B4%A6%E8%BD%AF%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E7%AF%87/"},{"title":"记账软件（二）新款App篇","text":"记账痛点现有使用的记账是随手记，遇到的痛点： 存在记错记漏的情况。 随手记打开有几秒钟的广告，影响使用体验。 使用随手记这类的软件需要一天大量的打开来避免记漏，过于繁琐。 评判标准，优先度由高到低 UI合理美观，操作合理。 因为是迁移，所以必须要有导入功能。 有web端加分。 全免费最好，其次接受买断制，不想使用订阅制，对广告忍受力较低。 导出无限制加分。 处在正常更新，不求新功能，只求不跑路。 参赛软件 图图记账 小象记账 Pixiu记账 钱去哪儿了 Beancount 图图记账 UI非常不错，很对我胃口。 单平台软件。 本地化支持好，新建帐号自带常用的微信支付宝和各个银行。 不开会员限制较大，不能使用同步，只能建立三个账户，不买会员难以日常使用。会员有包月包年和买断制，按年付费68元，买断128元。 支持从多平台导入，导出需要会员。 图片 小象记账 UI还不错，不过稍微有点简陋。 内置的帐号还比较简陋，银行帐号没法选择具体银行，也没有图标可选。 自带的分类很简单，如果需要二级分类需要开会员，没有默认配置。 支持WebDAV备份，好评。 支持IOS和安卓双平台。 资产统计需要会员，账单导出需要会员，其他没什么限制，会员也是非常的便宜，按年12元，按季3元，不过没有买断。 图片 Pixiu记账 UI非常的原生简陋，统计界面也是非常简陋。 记账默认使用月视图，有新意，但是UI非常的简陋。 信用卡账户支持按还款周期显示，好评。 支持的帐号种类非常多，包括证券帐号、社保帐号、保险帐号等等。 支持报销、借款、坏账、证券相关的各种操作，好评，不过全部需要会员才能使用。 支持股票、基金、理财产品的信息维护，不过全部需要会员。 不支持打开一个帐号后直接在该帐号中记账，只能使用中间记账按钮，感觉很别扭。 记账界面非常的奇怪，在默认的图标模式里，因为使用的是Emoji，开发者也没有细心调整，各种项目使用的都是相同的图标，看起来很混乱。默认的分类也很奇怪，比如饮料下面还区分的奶茶和功能饮料，过于的细致。而且一些项目是一级菜单，点开之后还有一层要选，有一些是一级菜单，从视觉上看却没有差距，用起来很迷惑。 会员功能包含同步、导入导出、帐号排序、帐号批量管理，就连复制功能都要会员，没有买断，只有包年38元。 图片 钱去哪儿了 UI大部分使用原生元素。 支持查看一笔记账同类型的其他记账记录，好评。 导出导出不限制，不需要会员，好评。 特色功能：支持使用小组件快速记录固定金额和项目的内容，不过对应免费用户只支持三个配置。 可以新建大量的帐号，但是每个帐号没有区别，不能自定义图标，不能备注，每个帐号唯一的区别可能就是名字了。 会员功能包括iCloud备份、支持多产品（全部是苹果产品），没有买断，一个月1.99元，一年15元。 Beancount 和上面的记账都不同，所以我先试用一段时间再做评价。目前已知的特点是复式的命令行记账，没有移动端，不过也不需要随时随地的记账大多数人使用都是基于支付宝微信和银行的账单来批量导入，虽然感觉有一点麻烦，但是如果能搞定的话感觉会更方便，最近会仔细研究研究。后面会单出一篇博文来介绍使用感受。 总结测试了一下最近新发现的几款记账软件，基本都上市没多久，使用起来都不是很靠谱，比较喜欢的是图图记账，其他的几个都不是很推荐。我就继续用着随手记了，期待更好的选择出现。近期尝试一下复式记账。","link":"/2021/05/24/%E8%AE%B0%E8%B4%A6%E8%BD%AF%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E6%96%B0%E6%AC%BEApp%E7%AF%87/"}],"tags":[{"name":"回顾","slug":"回顾","link":"/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"理财","slug":"理财","link":"/tags/%E7%90%86%E8%B4%A2/"},{"name":"比特币","slug":"比特币","link":"/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"},{"name":"王小波","slug":"王小波","link":"/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"},{"name":"基金","slug":"基金","link":"/tags/%E5%9F%BA%E9%87%91/"},{"name":"Firefox","slug":"Firefox","link":"/tags/Firefox/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"键盘","slug":"键盘","link":"/tags/%E9%94%AE%E7%9B%98/"},{"name":"记账","slug":"记账","link":"/tags/%E8%AE%B0%E8%B4%A6/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"}],"categories":[{"name":"书摘","slug":"书摘","link":"/categories/%E4%B9%A6%E6%91%98/"},{"name":"记录","slug":"记录","link":"/categories/%E8%AE%B0%E5%BD%95/"},{"name":"书海计划","slug":"书海计划","link":"/categories/%E4%B9%A6%E6%B5%B7%E8%AE%A1%E5%88%92/"}]}